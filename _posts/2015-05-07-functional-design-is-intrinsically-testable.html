---
layout: post
title: "Functional design is intrinsically testable"
date: 2015-05-07 6:13 UTC
tags: [Unit Testing, Software Design, Functional Programming]
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>TDD with Functional Programming doesn't lead to test-induced damage. Here's why.</em>
  </p>
  <p>
    Over the years, there's been much criticism of Test-Driven Development (TDD). Perhaps <a href="http://david.heinemeierhansson.com">David Heinemeier Hansson</a> best condensed this criticism by claiming that <a href="http://david.heinemeierhansson.com/2014/test-induced-design-damage.html">TDD leads to test-induced design damage</a>. This isn't a criticism you can just brush away; it hits a sore point.
  </p>
  <p>
    Personally, I don't believe that TDD <em>has</em> to lead to test-induced damage (not even in Object-Oriented Programming), but I'm the first to admit that <a href="http://blog.ploeh.dk/2010/12/22/TheTDDApostate">it's not a design methodology</a>.
  </p>
  <p>
    In this article, though, you're going to learn about the fundamental reason that TDD with <em>Functional Programming</em> doesn't lead to test-induced damage.
  </p>
  <p>
    In Functional Programming, the ideal function is a <a href="http://en.wikipedia.org/wiki/Pure_function">Pure function</a>. A Pure function is a function that always returns the same value given the same input, and has no side-effects.
  </p>
  <p>
    <strong>Isolation</strong>
  </p>
  <p>
    The first characteristic of a Pure function means that an ideal function can't depend on any implicit knowledge about the external world. Only the input into the function can influence the evaluation of the function.
  </p>
  <p>
    This is what <a href="http://jessitron.com">Jessica Kerr</a> <a href="http://www.functionalgeekery.com/episode-8-jessica-kerr">calls <em>Isolation</em></a>. A function has the property of Isolation when the only information it has about the external word is passed into it via arguments.
  </p>
  <p>
    You can think about Isolation as the <em>dual</em> of Encapsulation.
  </p>
  <p>
    In Object-Oriented Programming, <a href="http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29">Encapsulation</a> is a very important concept. It means that while an object contains state, the external world doesn't know about that state, unless the object <strong>explicitly makes it available</strong>.
  </p>
  <p>
    In Functional Programming, a function is Isolated when it knows nothing about the state of the external world, unless it's <strong>explicitly made available to it</strong>.
  </p>
  <p>
    A Pure function, the ideal of Functional Programming, is Isolated.
  </p>
  <p>
    <strong>Unit testing</strong>
  </p>
  <p>
    Why is this interesting?
  </p>
  <p>
    It's interesting if you start to think about what unit testing means. There are tons of conflicting definitions of what exactly constitutes a unit test, but most experts seem to be able to agree on this broad definition:
    <blockquote>
      A unit test is an automated test that tests a unit in isolation from its dependencies.
    </blockquote>
    Notice the use of the word <em>Isolation</em> in that definition. In order to unit test, you'll have to be able to isolate the unit from its dependencies. This is the requirement that tends to lead to Test-Induced Damage in Object-Oriented Programming. While there's nothing about Encapsulation that explicitly states that it's forbidden to isolate an object from its dependencies, it offers no help on the matter either. Programmers are on their own, because this concern isn't ingrained into Object-Oriented Programming.
  </p>
  <p>
    <img src="/content/binary/encapsulation-isolation-venn.png" alt="Venn diagram showing that while there's an intersection between Encapsulation and Isolation, it's only here that Object-Oriented Programming is also testable.">
  </p>
  <p>
    You can do TDD with Object-Oriented Programming, and as long as you stay within the intersection of Encapsulation and Isolation, you may be able to stay clear of test-induced damage. However, that zone of testability isn't particularly big, so it's easy to stray. You have to be very careful and know what you're doing. Not surprisingly, many books and articles have been written about TDD, including <a href="http://blog.ploeh.dk/tags.html#Unit Testing-ref">quite a few on this blog</a>.
  </p>
  <p>
    <strong>The best of both worlds</strong>
  </p>
  <p>
    In Functional Programming, on the other hand, Isolation is the ideal. An ideal function is already isolated from its dependencies, so no more design work is required to make it testable.
  </p>
  <p>
    <img src="/content/binary/ideal-function-isolation-testability-stacked-venn.png" alt="Stacked Venn diagram that show that an ideal function is a subset of isolated functions, which is again a subset of testable functions.">
  </p>
  <p>
    Ideal Functional design is not only ideal, but also perfectly testable, so there's no conflict. This is the underlying reason that TDD doesn't lead to test-induced damage with Functional Programming.
  </p>
  <p>
    <strong>Summary</strong>
  </p>
  <p>
    Isolation is an important quality of Functional Programming. An ideal function is Isolated, and that means that it's intrinsically testable. You don't have to tweak any design principles in order to make a function testable - in fact, if a function isn't testable, it's a sign that it's poorly designed. Thus, <strong>TDD doesn't lead to Test-Induced Damage in Functional Programming</strong>.
  </p>
  <p>
    If you want to learn more about this, as well as see lots of code examples, you can watch my <a href="{{ site.production_url }}/tdd-with-fsharp">Test-Driven Development with F#</a> Pluralsight course.
  </p>
</div>