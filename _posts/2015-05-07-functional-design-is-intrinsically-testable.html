---
layout: post
title: "Functional design is intrinsically testable"
description: "TDD with Functional Programming doesn't lead to test-induced damage. Here's why."
date: 2015-05-07 6:13 UTC
tags: [Unit Testing, Software Design, Functional Programming]
image: "/content/binary/ideal-function-isolation-testability-stacked-venn.png"
image_alt: "Stacked Venn diagram that show that an ideal function is a subset of isolated functions, which is again a subset of testable functions."
---
{% include JB/setup %}

<div id="post">
  <p>
    <em>{{ page.description }}</em>
  </p>
  <p>
    Over the years, there's been much criticism of Test-Driven Development (TDD). Perhaps <a href="http://david.heinemeierhansson.com">David Heinemeier Hansson</a> best condensed this criticism by claiming that <a href="http://david.heinemeierhansson.com/2014/test-induced-design-damage.html">TDD leads to test-induced design damage</a>. This isn't a criticism you can just brush away; it hits a sore point.
  </p>
  <p>
    Personally, I don't believe that TDD <em>has</em> to lead to test-induced damage (not even in Object-Oriented Programming), but I'm the first to admit that <a href="/2010/12/22/TheTDDApostate">it's not a design methodology</a>.
  </p>
  <p>
    In this article, though, you're going to learn about the fundamental reason that TDD with <em>Functional Programming</em> doesn't lead to test-induced damage.
  </p>
  <p>
    In Functional Programming, the ideal function is a <a href="http://en.wikipedia.org/wiki/Pure_function">Pure function</a>. A Pure function is a function that always returns the same value given the same input, and has no side-effects.
  </p>
  <h3 id="a20359945e5c406a8dbf3bd692dc2a1b">
    Isolation <a href="#a20359945e5c406a8dbf3bd692dc2a1b" title="permalink">#</a>
  </h3>
  <p>
    The first characteristic of a Pure function means that an ideal function can't depend on any implicit knowledge about the external world. Only the input into the function can influence the evaluation of the function.
  </p>
  <p>
    This is what <a href="http://jessitron.com">Jessica Kerr</a> <a href="http://www.functionalgeekery.com/episode-8-jessica-kerr">calls <em>Isolation</em></a>. A function has the property of Isolation when the only information it has about the external word is passed into it via arguments.
  </p>
  <p>
    You can think about Isolation as the <em>dual</em> of Encapsulation.
  </p>
  <p>
    In Object-Oriented Programming, <a href="http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29">Encapsulation</a> is a very important concept. It means that while an object contains state, the external world doesn't know about that state, unless the object <strong>explicitly makes it available</strong>.
  </p>
  <p>
    In Functional Programming, a function is Isolated when it knows nothing about the state of the external world, unless it's <strong>explicitly made available to it</strong>.
  </p>
  <p>
    A Pure function, the ideal of Functional Programming, is Isolated.
  </p>
  <h3 id="55f5f9040e4b434cad839390ec1f038c">
    Unit testing <a href="#55f5f9040e4b434cad839390ec1f038c" title="permalink">#</a>
  </h3>
  <p>
    Why is this interesting?
  </p>
  <p>
    It's interesting if you start to think about what unit testing means. There are tons of conflicting definitions of what exactly constitutes a unit test, but most experts seem to be able to agree on this broad definition:
    <blockquote>
      A unit test is an automated test that tests a unit in isolation from its dependencies.
    </blockquote>
    Notice the use of the word <em>Isolation</em> in that definition. In order to unit test, you'll have to be able to isolate the unit from its dependencies. This is the requirement that tends to lead to Test-Induced Damage in Object-Oriented Programming. While there's nothing about Encapsulation that explicitly states that it's forbidden to isolate an object from its dependencies, it offers no help on the matter either. Programmers are on their own, because this concern isn't ingrained into Object-Oriented Programming.
  </p>
  <p>
    <img src="/content/binary/encapsulation-isolation-venn.png" alt="Venn diagram showing that while there's an intersection between Encapsulation and Isolation, it's only here that Object-Oriented Programming is also testable.">
  </p>
  <p>
    You can do TDD with Object-Oriented Programming, and as long as you stay within the intersection of Encapsulation and Isolation, you may be able to stay clear of test-induced damage. However, that zone of testability isn't particularly big, so it's easy to stray. You have to be very careful and know what you're doing. Not surprisingly, many books and articles have been written about TDD, including <a href="/tags.html#Unit Testing-ref">quite a few on this blog</a>.
  </p>
  <h3 id="05e982d1b87b46e6a4b963ac8280c99b">
    The best of both worlds <a href="#05e982d1b87b46e6a4b963ac8280c99b" title="permalink">#</a>
  </h3>
  <p>
    In Functional Programming, on the other hand, Isolation is the ideal. An ideal function is already isolated from its dependencies, so no more design work is required to make it testable.
  </p>
  <p>
    <img src="/content/binary/ideal-function-isolation-testability-stacked-venn.png" alt="Stacked Venn diagram that show that an ideal function is a subset of isolated functions, which is again a subset of testable functions.">
  </p>
  <p>
    Ideal Functional design is not only ideal, but also perfectly testable, so there's no conflict. This is the underlying reason that TDD doesn't lead to test-induced damage with Functional Programming.
  </p>
  <h3 id="f042d2da84424c76a424b70faea121c9">
    Summary <a href="#f042d2da84424c76a424b70faea121c9" title="permalink">#</a>
  </h3>
  <p>
    Isolation is an important quality of Functional Programming. An ideal function is Isolated, and that means that it's intrinsically testable. You don't have to tweak any design principles in order to make a function testable - in fact, if a function isn't testable, it's a sign that it's poorly designed. Thus, <strong>TDD doesn't lead to Test-Induced Damage in Functional Programming</strong>.
  </p>
  <p>
    If you want to learn more about this, as well as see lots of code examples, you can watch my <a href="{{ site.production_url }}/tdd-with-fsharp">Test-Driven Development with F#</a> Pluralsight course.
  </p>
</div>

<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="e1992711a2074e068fd3372e65cddbf7">
		<div class="comment-author">Tyson Williams</div>
		<div class="comment-content">
			<blockquote>
				A Pure function is a function that always returns the same value given the same input, and has no side-effects.
			</blockquote>
			<p>
				What do you mean by "value"?  Can an exception instance be a value?  More specifically, would you say that the C# function <code>int Foo() =&gt; new Exception();</code> is pure?
			</p>
			<p>
				Many of your posts mention pure funcitons and at least a few of them include your own definition.  I decided to comment on this post since it was the oldest post I found that included your own definition of a pure function.
			</p>
		</div>
		<div class="comment-date">2020-03-06 22:50 UTC</div>
	</div>

  <div class="comment" id="8357b5ab8ada4f44bf17dcacd9b9b079">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Tyson, thank you for writing. I don't think that <code>int Foo() =&gt; new Exception();</code> compiles...
      </p>
      <p>
        Apart from that, how do you find that this is my own definition of a pure function? It seems to me to be a standard and non-controversial definition. I even <a href="https://en.wikipedia.org/wiki/Pure_function">link to the Wikipedia definition</a> in the beginning of the article.
      </p>
    </div>
    <div class="comment-date">2020-03-07 8:49 UTC</div>
  </div>

	<div class="comment" id="f7819c9f3a304c86a4f14b2833674a34">
		<div class="comment-author">Tyson Williams</div>
		<div class="comment-content">
			<blockquote>
				Apart from that, how do you find that this is my own definition of a pure function? It seems to me to be a standard and non-controversial definition. I even <a href="https://en.wikipedia.org/wiki/Pure_function">link to the Wikipedia definition</a> in the beginning of the article.
			</blockquote>
			<p>
				I am not trying claim that any particular definition of a pure function is non-standard or is controversial.  I also don't mean that the text I quoted is "your definition" in the sense that it semantically differs from the one on Wikipedia.  I just mean that it is "your definition" in the sense that you have syntactically included in your post the text that I quoted.
			</p>
			<p>
				However, I am unsure about the precise meaning the defintion for a pure function that you have syntactically included in your post and that I quoted.  To help me improve my understanding of that defintion, I tried to ask you if a particular C# function is pure.
			</p>
			<blockquote>
				I don't think that <code>int Foo() =&gt; new Exception();</code> compiles...
			</blockquote>
			<p>
				Ah, yes.  Thanks for alerting me to my mistake.  I meant to include the <code>throws</code> keyword as well.  For clarity, I now repeat that whole paragraph but with the prose "thrown" and the keyword <code>throws</code> added.
			</p>
			<p>
				What do you mean by "value"?  Can a thrown exception instance be a value?  More specifically, would you say that the C# function <code>int Foo() =&gt; throws new Exception();</code> is pure?
			</p>
		</div>
		<div class="comment-date">2020-03-07 12:27 UTC</div>
	</div>

  <div class="comment" id="97e4ae29436e4828813bf445ee1c37dc">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        Tyson, your code still doesn't compile, but I think I understand the question 😜
      </p>
      <p>
        Yes, <code>int Foo() =&gt; throw new Exception();</code> is still a pure function, but it isn't <em>total</em>. Rather, it's a <a href="https://en.wikipedia.org/wiki/Partial_function">partial function</a>. This is an independent quality of functions.
      </p>
      <p>
        Purity relates to determinism and the lack of side effects. A total function, on the other hand, is a function that returns a proper value for every possible value in its <em>domain</em>. What do I mean by <em>proper?</em>
      </p>
      <p>
        There's two ways in which a function can fail to return a value. One is if the function never returns. Due to the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a> there's no general-purpose way to determine whether or not this is the case for a Turing-complete language.
      </p>
      <p>
        Another way a function can fail to return a value is if it throws an exception. Most languages (even Haskell!) allows exception-throwing. This isn't considered a 'proper' value because, using the type system, you declared that <code>Foo</code> returns an <code>int</code>. It doesn't. It 'returns' an exception.
      </p>
      <p>
        Both non-termination and exceptions are typically considered a special value termed <em>bottom</em>, often written with the symbol <code>⊥</code>.
      </p>
      <p>
        Functions can be pure, but partial. Your <code>Foo</code> function is an example of that. The holy grail in statically typed functional programming is pure and total functions. It's up to the programmer to provide the totality guarantee, though, since the type system can't enforce termination (due to the halting problem). You can, on the other hand, easily program without exceptions once you get the hang of it.
      </p>
    </div>
    <div class="comment-date">2020-03-07 13:21 UTC</div>
  </div>

	<div class="comment" id="eacb540e91fb47e6bf6296c520522aaa">
		<div class="comment-author">Tyson Williams</div>
		<div class="comment-content">
			<p>
				Thanks for seeing pass my second compile error and understanding my question.
			</p>
			<p>
				Ah, yes.  I definitely know about partial and total functions from my experience with mathematics, and I am pretty sure I have previously called a function that throws an exception partial, but I completely forgot about this connection.  (I think that is because I have so focused on purity.)  Thank you for bringing this concept (back) to my attention.
			</p>
			<blockquote>
				[The definition of a pure funciton in question] seems to me to be a standard and non-controversial definition.
			</blockquote>
			<p>
				I was asking about pure functions and exception throwing because I was thinking about the definition for a pure function given by Enrico Buonanno in <a href="https://www.manning.com/books/functional-programming-in-c-sharp">Functional Programming in C#</a>.  He considers throwing an exception a side effect and includes this paragraph about this decision.
			</p>
			<blockquote>
				Some will argue that a function can be considered pure despite throwing exceptions. However, in throwing exceptions it will cause indeterminism to appear in code that makes some decisions based on exception handling, or in the absence of exception handling, in the side effect of the program crashing.
			</blockquote>
			<p>
				What do you think about Enrico's choice to define exception throwing as a side effect?
			</p>
			<p>
				It might be worth considering <code>async void Foo() =&gt; throw new Exception();</code> because it produces an unhandled exception, which crashes the executing process.
			</p>
		</div>
		<div class="comment-date">2020-03-09 03:59 UTC</div>
	</div>

  <div class="comment" id="7bdf9f1597334a40afe4b8488456d7b2">
    <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
    <div class="comment-content">
      <p>
        I haven't seen anyone take that position before, so I can only evaluate it based on what you wrote. With that limited context, however, I don't find the argument convincing. First, that throwing exceptions will cause indeterminism to appear in code that handles exceptions says nothing about the function that throws the exception. It says something about the code that handles the exception.
      </p>
      <p>
        Making decisions based on data is itself not non-deterministic. If it was, <code>if/else</code> blocks or pattern matching couldn't be pure. If the exception handler does something impure while handling an exception, then it's just an impure action. The <a href="/2018/11/19/functional-architecture-a-definition">functional interaction law</a> explicitly allows this.
      </p>
      <p>
        Keep in mind that the definition of purity that we're discussing is really only a checklist to figure out whether a function is <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>. That's the core definition: Can you replace a function call with its result?
      </p>
      <p>
        Yes, if the function is pure. This includes a function that throws an exception. It basically just returns <code>⊥</code>. If you have code that handles the exception, it'll do that based on the exception that was thrown. It doesn't really matter if the function 'actually executed' or not. We can replace the function call with the <em>bottom</em> value.
      </p>
      <p>
        If you don't handle the exception, then yes: the program crashes. It'll do so, however, regardless of whether you 'run' the function, or you just replace it with a thrown exception.
      </p>
    </div>
    <div class="comment-date">2020-03-11 18:50 UTC</div>
  </div>

	<div class="comment" id="e118a437e8a84a9d95bd117bbe597084">
		<div class="comment-author">Tyson Williams</div>
		<div class="comment-content">
			<p>
				Yes, this helps.  I agree with you.  Thanks for your explanation.
			</p>
			<blockquote>
				Due to the <a href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a> there's no general-purpose way to determine whether or not this is the case for a Turing-complete language.<br>
				...<br>
				It's up to the programmer to provide the totality guarantee, though, since the type system can't enforce termination (due to the halting problem).
			</blockquote>
			<p>
				The respective problems of deciding if a given function is total or pure are equally difficult; both are undecidable by <a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice's theorem</a>.  A compiler for Haskell is not a general-purpose algorithm for deciding the purity of a function.  It follows from the syntax of Haskell that all functions in Haskell with a return type different from the IO monad are pure (and technically all the others as well).  Rice's theorem doesn't apply when the property being checked is syntactic.
			</p>
			<p>
				In the same way, it is possible to design a programming language with two contexts: one in which partial functions can be defined and another in which only total functions can be defined.  As before, the partial function context could be expressed by the syntactic requirement that the return type is some monad.
			</p>
		</div>
		<div class="comment-date">2020-03-11 09:08 UTC</div>
	</div>
</div>