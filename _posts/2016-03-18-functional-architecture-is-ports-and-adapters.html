---
layout: post
title: "Functional architecture is Ports and Adapters"
date: 2016-03-18 08:53 UTC
tags: [Software Design, Architecture, F#, Haskell]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Functional architecture tends to fall into a pit of success that looks a lot like Ports and Adapters.</em>
	</p>
	<p>
		In object-oriented architecture, we often struggle towards the ideal of the Ports and Adapters architecture, although we often <a href="http://blog.ploeh.dk/2013/12/03/layers-onions-ports-adapters-its-all-the-same">call it something else: layered architecture, onion architecture, hexagonal architecture, and so on</a>. The goal is to decouple the business logic from technical implementation details, so that we can vary each independently.
	</p>
	<p>
		This creates value because it enables us to manoeuvre nimbly, responding to changes in business or technology.
	</p>
	<p>
		<strong>Ports and Adapters</strong>
	</p>
	<p>
		The idea behind the Ports and Adapters architecture is that <em>ports</em> make up the boundaries of an application. A <em>port</em> is something that interacts with the outside world: user interfaces, message queues, databases, files, command-line prompts, etcetera. While the ports constitute the interface to the rest of the world, <em>adapters</em> translate between the ports and the application model.
	</p>
	<p>
		<img src="/content/binary/ports-and-adapters-conceptual-diagram.png" alt="A conceptual diagram of Ports and Adapters architecture: coloured boxes in concentric circles.">
	</p>
	<p>
		The word <em>adapter</em> is aptly chosen, because the role of the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapter design pattern</a> is exactly to translate between two different interfaces.
	</p>
	<p>
		You ought to arrive at some sort of variation of Ports and Adapters if you apply Dependency Injection, as <a href="http://blog.ploeh.dk/2013/12/03/layers-onions-ports-adapters-its-all-the-same">I've previously attempted to explain</a>.
	</p>
	<p>
		The problem with this architecture, however, is that it seems to take a lot of explaining:
		<ul>
			<li><a href="http://amzn.to/12p90MG">My book about Dependency Injection</a> is 500 pages long.</li>
			<li>Robert C. Martin's <a href="http://amzn.to/19W4JHk">book about the SOLID principles, package and component design, and so on</a> is 700 pages long.</li>
			<li><a href="http://amzn.to/WBCwx7">Domain-Driven Design</a> is 500 pages long.</li>
			<li>and so on...</li>
		</ul>
		In my experience, implementing a Ports and Adapters architecture is a <a href="https://en.wikipedia.org/wiki/Sisyphus">Sisyphean task</a>. It requires much diligence, and if you look away for a moment, the boulder rolls downhill again.
	</p>
	<p>
		<img src="/content/binary/sisyphos-boulder-rolling-downhill.png" alt="A schematic showing a ball rolling down a slope.">
	</p>
	<p>
		It's possible to implement a Ports and Adapters architecture with object-oriented programming, but it takes <em>so much effort</em>. Does it have to be that difficult?
	</p>
	<p>
		<strong>Haskell as a learning aid</strong>
	</p>
	<p>
		Someone recently asked me: <em>how do I know I'm being sufficiently Functional?</em>
	</p>
	<p>
		I was wondering that myself, so I decided to learn Haskell. Not that Haskell is the only Functional language out there, but it enforces <a href="https://en.wikipedia.org/wiki/Pure_function">purity</a> in a way that neither F#, Clojure, nor Scala does. In Haskell, a function <em>must</em> be pure, unless its type indicates otherwise. This forces you to be deliberate in your design, and to separate pure functions from functions with (side) effects.
	</p>
	<p>
		If you don't know Haskell, code with side effects can only happen inside of a particular 'context' called <code>IO</code>. It's a monadic type, but that's not the most important point. The point is that you can tell by a function's type whether or not it's pure. A function with the type <code>ReservationRendition -&gt; Either Error Reservation</code> is pure, because <code>IO</code> appears nowhere in the type. On the other hand, a function with the type <code>ConnectionString -&gt; ZonedTime -&gt; IO Int</code> is impure because its return type is <code>IO Int</code>. This means that the return value is an integer, but that this integer originates from a context where it could change between function calls.
	</p>
	<p>
		There's a fundamental distinction between a function that returns <code>Int</code>, and one that returns <code>IO Int</code>. Any function that returns <code>Int</code> is, in Haskell, <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>. This means that you're guaranteed that the function will always return the same value given the same input. On the other hand, a function returning <code>IO Int</code> doesn't provide such a guarantee.
	</p>
	<p>
		In Haskell programming, you should strive towards maximising the amount of pure functions you write, pushing the impure code to the edges of the system. A good Haskell program has a big core of pure functions, and a shell of <code>IO</code> code. Does that sound familiar?
	</p>
	<p>
		It basically means that Haskell's type system <em>enforces</em> the Ports and Adapters architecture. The <em>ports</em> are all your <code>IO</code> code. The application's core is all your pure functions. The type system automatically creates a <em>pit of success</em>.
	</p>
	<p>
		<img src="/content/binary/pit-of-success.png" alt="A 'boulder' lying in the bottom of a schematised pit of success.">
	</p>
	<p>
		Haskell is a great learning aid, because it forces you to explicitly make the distinction between pure and impure functions. You can even use it as a verification step to figure out whether your F# code is 'sufficiently Functional'. F# is a <em>Functional first</em> language, but it also allows you to write object-oriented or imperative code. If you write your F# code in a Functional manner, though, it's easy to translate to Haskell. If your F# code is difficult to translate to Haskell, it's probably because it isn't Functional.
	</p>
	<p>
		Here's an example.
	</p>
	<p>
		<strong>Accepting reservations in F#, first attempt</strong>
	</p>
	<p>
		In my <a href="http://bit.ly/tddwithfsharp">Test-Driven Development with F#</a>	Pluralsight course (a <a href="http://www.infoq.com/presentations/mock-fsharp-tdd">free, condensed version is also available</a>), I demonstrate how to implement an HTTP API that accepts reservation requests for an on-line restaurant booking system. One of the steps when handling the reservation request is to check whether the restaurant has enough remaining capacity to accept the reservation. The function looks like this:
	</p>
	<p>
		<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:green;">//&nbsp;int</span>
<span style="color:green;">//&nbsp;-&gt;&nbsp;(DateTimeOffset&nbsp;-&gt;&nbsp;int)</span>
<span style="color:green;">//&nbsp;-&gt;&nbsp;Reservation</span>
<span style="color:green;">//&nbsp;-&gt;&nbsp;Result&lt;Reservation,Error&gt;</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">check</span>&nbsp;capacity&nbsp;<span style="color:navy;">getReservedSeats</span>&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;reservedSeats&nbsp;=&nbsp;<span style="color:navy;">getReservedSeats</span>&nbsp;reservation.Date
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;capacity&nbsp;&lt;&nbsp;reservation.Quantity&nbsp;+&nbsp;reservedSeats
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;<span style="color:navy;">Failure</span>&nbsp;<span style="color:navy;">CapacityExceeded</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:navy;">Success</span>&nbsp;reservation</pre>
	</p>
	<p>
		As the comment suggests, the second argument, <code>getReservedSeats</code>, is a function of the type <code>DateTimeOffset -&gt; int</code>. The <code>check</code> function calls this function to retrieve the number of already reserved seats on the requested date.
	</p>
	<p>
		When unit testing, you can supply a pure function as a Stub; for example:
	</p>
	<p>
		<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">let</span>&nbsp;<span style="color:navy;">getReservedSeats</span>&nbsp;_&nbsp;=&nbsp;0
 
<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;<span style="color:#4ec9b0;">Capacity</span>.<span style="color:navy;">check</span>&nbsp;capacity&nbsp;<span style="color:navy;">getReservedSeats</span>&nbsp;reservation</pre>
	</p>
	<p>
		When finally composing the application, instead of using a pure function with a hard-coded return value, you can compose with an impure function that queries a database for the desired information:
	</p>
	<p>
		<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">let</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Validate</span>.<span style="color:navy;">reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;<span style="color:navy;">bind</span>&nbsp;(<span style="color:#4ec9b0;">Capacity</span>.<span style="color:navy;">check</span>&nbsp;10&nbsp;(<span style="color:#4ec9b0;">SqlGateway</span>.<span style="color:navy;">getReservedSeats</span>&nbsp;connectionString))
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;<span style="color:navy;">map</span>&nbsp;(<span style="color:#4ec9b0;">SqlGateway</span>.<span style="color:navy;">saveReservation</span>&nbsp;connectionString)</pre>
	</p>
	<p>
		Here, <code>SqlGateway.getReservedSeats connectionString</code> is a partially applied function, the type of which is <code>DateTimeOffset -&gt; int</code>. In F#, you can't tell by its type that it's impure, but I know that this is the case because I wrote it. It queries a database, so isn't referentially transparent.
	</p>
	<p>
		This works well in F#, where it's up to you whether a particular function is pure or impure. Since that <code>imp</code> function is composed in the application's <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot">Composition Root</a>, the impure functions SqlGateway.getReservedSeats and SqlGateway.saveReservation are only pulled in at the edge of the system. The rest of the system is nicely protected against side-effects.
	</p>
	<p>
		It feels Functional, but is it?
	</p>
	<p>
		<strong>Feedback from Haskell</strong>
	</p>
	<p>
		In order to answer that question, I decided to re-implement the central parts of this application in Haskell. My first attempt to check the capacity was this direct translation:
	</p>
	<p>
		<pre>checkCapacity :: Int
              -&gt; (ZonedTime -&gt; Int)
              -&gt; Reservation
              -&gt; Either Error Reservation
checkCapacity capacity getReservedSeats reservation =
  let reservedSeats = getReservedSeats $ date reservation
  in if capacity &lt; quantity reservation + reservedSeats
      then Left CapacityExceeded
      else Right reservation</pre>
	</p>
	<p>
		This compiles, and at first glance seems promising. The type of the <code>getReservedSeats</code> function is <code>ZonedTime -&gt; Int</code>. Since <code>IO</code> appears nowhere in this type, Haskell guarantees that it's pure.
	</p>
	<p>
		On the other hand, when you need to implement the function to retrieve the number of reserved seats from a database, this function must, by its very nature, be impure, because the return value could change between two function calls. In order to enable that in Haskell, the function must have this type:
	</p>
	<p>
		<pre>getReservedSeatsFromDB :: ConnectionString -&gt; ZonedTime -&gt; IO Int</pre>
	</p>
	<p>
		While you can partially apply the first ConnectionString argument, the return value is <code>IO Int</code>, not <code>Int</code>.
	</p>
	<p>
		A function with the type <code>ZonedTime -&gt; IO Int</code> isn't the same as <code>ZonedTime -&gt; Int</code>. Even when executing inside of an IO context, you can't convert <code>ZonedTime -&gt; IO Int</code> to <code>ZonedTime -&gt; Int</code>.
	</p>
	<p>
		You can, on the other hand, <em>call</em> the impure function inside of an IO context, and extract the <code>Int</code> from the <code>IO Int</code>. That doesn't quite fit with the above checkCapacity function, so you'll need to reconsider the design. While it was 'Functional enough' for F#, it turns out that this design isn't <em>really</em> Functional.
	</p>
	<p>
		If you consider the above checkCapacity function, though, you may wonder why it's necessary to pass in a function in order to determine the number of reserved seats. Why not simply pass in this number instead?
	</p>
	<p>
		<pre>checkCapacity :: Int -&gt; Int -&gt; Reservation -&gt; Either Error Reservation
checkCapacity capacity reservedSeats reservation =
    if capacity &lt; quantity reservation + reservedSeats
    then Left CapacityExceeded
    else Right reservation</pre>
	</p>
	<p>
		That's much simpler. At the edge of the system, the application executes in an IO context, and that enables you to compose the pure and impure functions:
	</p>
	<p>
		<pre>import Control.Monad.Trans (liftIO)
import Control.Monad.Trans.Either (EitherT(..), hoistEither)

postReservation :: ReservationRendition -&gt; IO (HttpResult ())
postReservation candidate = fmap toHttpResult $ runEitherT $ do
  r &lt;- hoistEither $ validateReservation candidate
  i &lt;- liftIO $ getReservedSeatsFromDB connStr $ date r
  hoistEither $ checkCapacity 10 i r
  &gt;&gt;= liftIO . saveReservation connStr</pre>
	</p>
	<p>
		(Complete source code is available <a href="https://gist.github.com/ploeh/c999e2ae2248bd44d775">here</a>.)
	</p>
	<p>
		Don't worry if you don't understand all the details of this composition. The highlights are these:
	</p>
	<p>
		The postReservation function takes a ReservationRendition (think of it as a JSON document) as input, and returns an <code>IO (HttpResult ())</code> as output. The use of <code>IO</code> informs you that this entire function is executing within the IO monad. In other words: it's impure. This shouldn't be surprising, since this is the edge of the system.
	</p>
	<p>
		Furthermore, notice that the function <code>liftIO</code> is called twice. You don't have to understand exactly what it does, but it's necessary to use in order to 'pull out' a value from an <code>IO</code> type; for example pulling out the <code>Int</code> from an <code>IO Int</code>. This makes it clear where the pure code is, and where the impure code is: the liftIO function is applied to the functions getReservedSeatsFromDB and saveReservation. This tells you that these two functions are impure. By exclusion, the rest of the functions (validateReservation, checkCapacity, and toHttpResult) are pure.
	</p>
	<p>
		It's interesting to observe how you can interleave pure and impure functions. If you squint, you can almost see how the data flows from the pure validateReservation function, to the impure getReservedSeatsFromDB function, and then both output values (<code>r</code> and <code>i</code>) are passed to the pure checkCapacity function, and finally to the impure saveReservation function. All of this happens within an <code>(EitherT Error IO) () do</code> block, so if any of these functions return <code>Left</code>, the function short-circuits right there and returns the resulting error. See e.g. Scott Wlaschin's excellent article on <a href="http://fsharpforfunandprofit.com/posts/recipe-part2">railway-oriented programming</a> for an exceptional, lucid, clear, and visual introduction to the Either monad.
	</p>
	<p>
		The value from this expression is composed with the built-in runEitherT function, and again with this pure function:
	</p>
	<p>
		<pre>toHttpResult :: Either Error () -&gt; HttpResult ()
toHttpResult (Left (ValidationError msg)) = BadRequest msg
toHttpResult (Left CapacityExceeded) = StatusCode Forbidden
toHttpResult (Right ()) = OK ()</pre>
	</p>
	<p>
		The entire postReservation function is impure, and sits at the edge of the system, since it handles IO. The same is the case of the getReservedSeatsFromDB and saveReservation functions. I deliberately put the two database functions in the bottom of the below diagram, in order to make it look more familiar to readers used to looking at layered architecture diagrams. You can imagine that there's a cylinder-shaped figure below the circles, representing a database.
	</p>
	<p>
		<img src="/content/binary/haskell-post-reservation-ports-adapters.png" alt="Haskell solution with functions placed in a Ports and Adapters diagram.">
	</p>
	<p>
		You can think of the validateReservation and toHttpResult functions as belonging to the <em>application model</em>. While pure functions, they translate between the external and internal representation of data. Finally, the checkCapacity function is part of the application's Domain Model, if you will.
	</p>
	<p>
		Most of the design from my first F# attempt survived, apart from the Capacity.check function. Re-implementing the design in Haskell has taught me an important lesson that I can now go back and apply to my F# code.
	</p>
	<p>
		<strong>Accepting reservations in F#, even more Functionally</strong>
	</p>
	<p>
		Since the required change is so little, it's easy to apply the lesson learned from Haskell to the F# code base. The culprit was the Capacity.check function, which ought to instead be implemented like this:
	</p>
	<p>
		<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">let</span>&nbsp;<span style="color:navy;">check</span>&nbsp;capacity&nbsp;reservedSeats&nbsp;reservation&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;capacity&nbsp;&lt;&nbsp;reservation.Quantity&nbsp;+&nbsp;reservedSeats
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">then</span>&nbsp;<span style="color:navy;">Failure</span>&nbsp;<span style="color:navy;">CapacityExceeded</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>&nbsp;<span style="color:navy;">Success</span>&nbsp;reservation</pre>
	</p>
	<p>
		This simplifies the implementation, but makes the composition slightly more involved:
	</p>
	<p>
		<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">let</span>&nbsp;<span style="color:navy;">imp</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">Validate</span>.<span style="color:navy;">reservation</span>
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;<span style="color:navy;">map</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;r&nbsp;<span style="color:blue;">-&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#4ec9b0;">SqlGateway</span>.<span style="color:navy;">getReservedSeats</span>&nbsp;connectionString&nbsp;r.Date,&nbsp;r)
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;<span style="color:navy;">bind</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;(i,&nbsp;r)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#4ec9b0;">Capacity</span>.<span style="color:navy;">check</span>&nbsp;10&nbsp;i&nbsp;r)
&nbsp;&nbsp;&nbsp;&nbsp;&gt;&gt;&nbsp;<span style="color:navy;">map</span>&nbsp;(<span style="color:#4ec9b0;">SqlGateway</span>.<span style="color:navy;">saveReservation</span>&nbsp;connectionString)</pre>
	</p>
	<p>
		This almost looks more complicated than the Haskell function. Haskell has the advantage that you can automatically use any type that implements the <code>Monad</code> typeclass inside of a <code>do</code> block, and since <code>(EitherT Error IO) ()</code> is a Monad instance, the <code>do</code> syntax is available for free.
	</p>
	<p>
		You could do something similar in F#, but then you'd have to implement a custom computation expression builder for the Result type. Perhaps I'll do this in <a href="http://blog.ploeh.dk/2016/03/21/composition-with-an-either-computation-expression">a later blog post</a>...
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Good Functional design is equivalent to the Ports and Adapters architecture. If you use Haskell as a yardstick for 'ideal' Functional architecture, you'll see how its explicit distinction between pure and impure functions creates a pit of success. Unless you write your entire application to execute <em>within</em> the <code>IO</code> monad, Haskell will automatically enforce the distinction, and push all communication with the external world to the edges of the system.
	</p>
	<p>
		Some Functional languages, like F#, don't explicitly enforce this distinction. Still, in F#, it's easy to <em>informally</em> make the distinction and compose applications with impure functions pushed to the edges of the system. While this isn't enforced by the type system, it still feels natural.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">Comments</h2>
	<div class="comment">
		<div class="comment-author"><a href="https://baks.github.io">Arkadiusz K</a></div>
		<div class="comment-content">
			<p>Great post as always. However, I saw that you are using <em></em>IO monad</em>. I wonder if you shouldn't use <em>IO action</em> instead? To be honest, I'm not proficient in Haskell. But according to that <a href="http://blog.jle.im/entry/io-monad-considered-harmful.html">post</a> they are encouraging to use <em>IO action</em> rather than </em>IO monad</em> if we are not talking about monadic properties.</p>
		</div>
		<div class="comment-date">2016-03-18 23:00 UTC</div>
	</div>
	<div class="comment">
		<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Arkadiusz, thank you for writing. It's the first time I see <a href="http://blog.jle.im/entry/io-monad-considered-harmful.html">that post</a>, but if I understand the argument correctly, it argues against the (over)use of the monad <em>terminology</em> when talking about IO actions that aren't intrinsically monadic in nature. As far as I can tell, it doesn't argue against the use of the <code>IO</code> <em>type</em> in Haskell.
			</p>
			<p>
				It seems a reasonable point that it's unhelpful to newcomers to throw them straight into a discussion about monads, when all they want to see is a <em>hello world</em> example.
			</p>
			<p>
				As some of the comments to that post point out, however, you'll soon need to compose IO actions in Haskell, and it's the monadic nature of the <code>IO</code> type that enables the use of <code>do</code> blocks. (..or, if you want to be more specific, it seems that sometimes, all you need is a Functor. It hardly helps to talk about the <em>IO functor</em> instead of the <em>IO monad</em>, though...)
			</p>
			<p>
				I don't claim to be a Haskell expert, so there may be more subtle nuances in that article that simply went over my head. Still, within my current understanding, the discussion in this particular post of mine does relate to the IO <em>monad</em>.
			</p>
			<p>
				When I wrote the article, I chose my words with some caution. Notice that when I introduce the <code>IO</code> type my article, I mostly talk about it as a 'context'.
			</p>
			<p>
				When it comes to the discussion about the postReservation function, however, I pull out the stops and increasingly use the word <em>monad</em>. The reason is that this composition wouldn't be possible without the monadic properties of <code>IO</code>. Most of this function executes within a monadic 'stack': <code>EitherT Error IO</code>. EitherT is a monad transformer, and in order to be useful (e.g. composable in <code>do</code> blocks), the type it transforms must be a monad as well (or perhaps, as hinted above, a functor would be sufficient).
			</p>
			<p>
				I agree with Justin Le's article that overuse of <em>monad</em> is likely counterproductive. On the other hand, one can also fall into the opposite side. There are some educators who seem to avoid the word at any cost. That's not my policy. I try to use as precise language as possible. That means that I'll use <em>monad</em> when I talk about monads, and I'll avoid it when it isn't necessary. That's my goal, but I may not have achieved it. Do you think I used it incorrectly here?
			</p>
		</div>
		<div class="comment-date">2016-03-19 08:06 UTC</div>
	</div>
	<div class="comment">
		<div class="comment-author"><a href="https://baks.github.io">Arkadiusz K</a></div>
		<div class="comment-content">
			<p>Mark, thank you for your comprehensive explanation. I was rather just asking you about opinion on this topic. I didn't try to claim that you had used it incorrectly. Now, I see that as you wrote you are first talking about IO context and then about IO monad when it comes to use monadic properties.</p>
		</div>
		<div class="comment-date">2016-03-19 10:30 UTC</div>
	</div>
    <div class="comment">
        <div class="comment-author">John Dailey</div>
        <div class="comment-content">
            <p>
                Hello, thanks so much for your website and pluralsight library -- it's been a tremendous help to me getting started with F# and functional programming (and TDD to a degree).  I'm having some problems with the big picture question of how to structure applications, and this post is leaving me even more confused.
            </p>
            <p>
                I can't understand how some of the original code, and especially the changes made in this post could possibly scale to a larger or more complicated application.  Many real-life domain operations are going to need to query some data, make decisions based on that data, map that data into different domain objects, persist something, and so on.
            </p>
            <p>
                It seems like the end result is that we end up copying much of the meaningful internal logic of the domain out to this boundary area in the Web API project.  In this code we've extracted:
                <ul>
                    <li>The logic of only checking existing reservations on the same day as the day on the request</li>
                    <li>The logic of not saving a new reservation if the request failed the capacity check</li>
                </ul>
            </p>
            <p>
                Does that logic not properly belong 'behind the wall' inside the domain?  I would have expected to see a simple 'makeReserveration r' function as the public face to the domain.  
                Suppose the restaurant also had a desktop/kiosk application in their building to manage their reservation system.  
                Wouldn't we now be forced to duplicate this internal logic in the Composition Root of that application?
            </p>
            <p>
                What I instinctively want to gravitate towards is something like this:
            </p>
            <p>
                <pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:blue;">let internal</span>&nbsp;<span style="color:navy;">makeReservation' getReservedSeats saveReservation check r</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:navy;">(getReservedSeats</span>&nbsp;r.Date,&nbsp;r)
&nbsp;&nbsp;&nbsp;&nbsp;|>&nbsp;<span style="color:navy;">bind</span>&nbsp;(<span style="color:blue;">fun</span>&nbsp;(i,&nbsp;r)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:navy;">check</span>&nbsp;10&nbsp;i&nbsp;r)
&nbsp;&nbsp;&nbsp;&nbsp;|>&nbsp;<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">saveReservation</span>

<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">makeReservation</span>&nbsp;= makeReservation' SqlGateway.getReservedSeats SqlGateway.saveReservation Capacity.check
</pre>
            </p>

            <p>
                With this, the SqlGateway code needs be visible to the reservation code, putting it at the center of the app not on the edges.  However, are there any practical disadvantages to
                this if the code is disciplined to only use it within this sort of dependency injection?  What problems would I be likely to run into?
            </p>
            <p>
                At least as a beginner, this seems to me to have a couple advantages:
                <ul>
                    <li>From the perspective of the unit tests (which test makeReservation') it is a pure function, as you noted above.  Testability is no problem here.</li>
                    <li>Code at the UI/Presentation level is nice and tight -- just make sure you can successfully transform the JSON request into a domain request, then process the command result.</li>
                </ul>
            </p>
            <p>
                But most notable to me, dependencies are 'injected' right where they were needed.  Imagine a much more complicated aggregate operation like 'performOvernightCloseout' that needs to do many things like read cash register
                totals and send them to accounting, send timeclock info to HR, write order statistics to a reporting database, check inventory and create new orders for the following day.  Of course we'd break this down into a 
                hierarchy of functions, with top level orchestration calling down into increasingly specific functions, no function individually being too complicated.
            </p>
            <p>
                The original demo application would have to approach this scenario by passing in a huge number of functions to the operation root, which then parcels them out level by level where they
                are needed.  This would seem very brittle since any change in a low level function would require changes to the parameter list all the way up.
            </p>
            <p>
                With newer code shown in this post, it would seem impossible.  There might be a handful of small functions that can be in the central library, but the bulk of the logic is going to need 
                to be extracted into a now-500-line imp method in the Web API project, or whatever service is launching this operation.
            </p>
        </div>
        <div class="comment-date">2016-03-24 23:30 UTC</div>
    </div>
  <div class="comment">
		<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				John, thank you for writing. I'm not sure I can answer everything to your satisfaction in single response, but we can always view this as a beginning of longer interchange. Some of the doubts you express are ambiguous, so I'm not sure how to interpret them, but I'll do my best to be as explicit as possible.
			</p>
			<p>
				In the beginning of your comment, you write:
				<blockquote>
					"Many real-life domain operations are going to need to query some data, make decisions based on that data, map that data into different domain objects, persist something, and so on."
				</blockquote>
				This is exactly the reason why I like the reservation request example so much, because it does all of that. It queries data, because it reads the number of already reserved seats from a database. It makes decisions based on that data, because it decides whether or not it can accept the reservation based on the number of remaining seats. It maps from an external JSON (or XML) data format to a Reservation record type (belonging to the Domain Model, if you will); it also maps back to an HTTP response. Finally, the example also saves the reservation to the database, if it was accepted.
			</p>
			<p>
				When you say that we've extracted the logic, it's true, but I'm not sure what you mean by "behind the wall", but let's look at each of your bullet points in turn.
			</p>
			<p>
				<strong>Querying existing reservations</strong>
			</p>
			<p>
				You write that I've extracted the "logic of only checking existing reservations on the same day as the day on the request". It's a simple database query. In F#, one implementation may look like this:
			</p>
			<p>
				<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:green;">//&nbsp;In&nbsp;module&nbsp;SqlGateway:</span>
<span style="color:blue;">let</span>&nbsp;<span style="color:navy;">getReservedSeats</span>&nbsp;connectionString&nbsp;(date&nbsp;:&nbsp;<span style="color:#4ec9b0;">DateTimeOffset</span>)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;min&nbsp;=&nbsp;<span style="color:#4ec9b0;">DateTimeOffset</span>(date.Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;date.Offset)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;max&nbsp;=&nbsp;<span style="color:#4ec9b0;">DateTimeOffset</span>(date.Date.<span style="color:navy;">AddDays</span>&nbsp;1.,&nbsp;date.Offset)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;sql&nbsp;=&nbsp;<span style="color:#a31515;">&quot;</span>
<span style="color:#a31515;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT&nbsp;ISNULL(SUM(Quantity),&nbsp;0)</span>
<span style="color:#a31515;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;[dbo].[Reservations]</span>
<span style="color:#a31515;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;@min&nbsp;&lt;=&nbsp;Date&nbsp;AND&nbsp;Date&nbsp;&lt;&nbsp;@max&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">use</span>&nbsp;conn&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#4ec9b0;">SqlConnection</span>(connectionString)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">use</span>&nbsp;cmd&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#4ec9b0;">SqlCommand</span>(sql,&nbsp;conn)
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.<span style="color:navy;">AddWithValue</span>(<span style="color:#a31515;">&quot;@min&quot;</span>,&nbsp;min)&nbsp;|&gt;&nbsp;<span style="color:navy;">ignore</span>
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.<span style="color:navy;">AddWithValue</span>(<span style="color:#a31515;">&quot;@max&quot;</span>,&nbsp;max)&nbsp;|&gt;&nbsp;<span style="color:navy;">ignore</span>
&nbsp;&nbsp;&nbsp;&nbsp;conn.<span style="color:navy;">Open</span>()
&nbsp;&nbsp;&nbsp;&nbsp;cmd.<span style="color:navy;">ExecuteScalar</span>()&nbsp;:?&gt;&nbsp;<span style="color:#4ec9b0;">int</span></pre>
			</p>
			<p>
				In my opinion, there's no <em>logic</em> in this function, but this is an example where terminology can be ambiguous. To me, however, <em>logic</em> implies that decisions are being made. That's not the case here. This getReservedSeats function has a cyclomatic complexity of 1.
			</p>
			<p>
				This function is an Adapter: it adapts the ADO.NET SDK (the <em>port</em> to SQL Server) to something the Domain Model can use. In this case, the answer is a simple integer.
			</p>
			<p>
				<strong>To save, or not to save</strong>
			</p>
			<p>
				You also write that I've extracted out the "logic of not saving a new reservation if the request failed the capacity check". Yes, that logic is extracted out to the <code>check</code> function above. Since that's a pure function, it's part of the Domain Model.
			</p>
			<p>
				The function that saves the reservation in the database, again, contains no logic (as I interpret the word <em>logic</em>):
			</p>
			<p>
				<pre style="font-family:Consolas;font-size:13;color:black;"><span style="color:green;">//&nbsp;In&nbsp;module&nbsp;SqlGateway:</span>
<span style="color:blue;">let</span>&nbsp;saveReservation&nbsp;connectionString&nbsp;(reservation&nbsp;:&nbsp;Reservation)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;sql&nbsp;=&nbsp;<span style="color:#a31515;">&quot;</span>
<span style="color:#a31515;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INSERT&nbsp;INTO&nbsp;Reservations(Date,&nbsp;Name,&nbsp;Email,&nbsp;Quantity)</span>
<span style="color:#a31515;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VALUES(@Date,&nbsp;@Name,&nbsp;@Email,&nbsp;@Quantity)&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">use</span>&nbsp;conn&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;SqlConnection(connectionString)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">use</span>&nbsp;cmd&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;SqlCommand(sql,&nbsp;conn)
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.AddWithValue(<span style="color:#a31515;">&quot;@Date&quot;</span>,&nbsp;reservation.Date)&nbsp;|&gt;&nbsp;ignore
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.AddWithValue(<span style="color:#a31515;">&quot;@Name&quot;</span>,&nbsp;reservation.Name)&nbsp;|&gt;&nbsp;ignore
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.AddWithValue(<span style="color:#a31515;">&quot;@Email&quot;</span>,&nbsp;reservation.Email)&nbsp;|&gt;&nbsp;ignore
&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.AddWithValue(<span style="color:#a31515;">&quot;@Quantity&quot;</span>,&nbsp;reservation.Quantity)&nbsp;|&gt;&nbsp;ignore
&nbsp;&nbsp;&nbsp;&nbsp;conn.Open()
&nbsp;&nbsp;&nbsp;&nbsp;cmd.ExecuteNonQuery()&nbsp;|&gt;&nbsp;ignore</pre>
			</p>
			<p>
				Due to the way the Either monad works, however, this function is only going to be called if all previous functions returned Success (or Right in Haskell). That logic is an entirely reusable abstraction. It's also part of the glue that composes functions together.
			</p>
			<p>
				<strong>Reuse of composition</strong>
			</p>
			<p>
				Further down, you ask:
				<blockquote>
					"Suppose the restaurant also had a desktop/kiosk application in their building to manage their reservation system. Wouldn't we now be forced to duplicate this internal logic in the Composition Root of that application?"
				</blockquote>
				That's an excellent question! I'm glad you asked.
			</p>
			<p>
				A desktop or kiosk application is noticeably different from a web application. It may have a different application flow, and it certainly exposes a different interface to the outside world. Instead of handling incoming HTTP requests, and translating results to HTTP responses, it'll need to respond to click events and transform results to on-screen UI events. This means that validation may be different, and that you don't need to map results back to HTTP response values. Again, this may be clearer in the Haskell implementation, where the <code>toHttpResult</code> function would obviously be superfluous. Additionally, a UI may present a native date and time picker control, which can directly produce strongly typed date and time values, negating the need for validation.
			</p>
			<p>
				Additionally, a kiosk may need to be able to work in off-line, or occasionally connected, mode, so perhaps you'd prefer a different data store implementation. Instead of connecting directly to a database, such an application would need to write to a message queue, and read from an off-line snapshot of reservations.
			</p>
			<p>
				That's a sufficiently different application that it warrants creating applications from <a href="http://blog.ploeh.dk/2011/06/07/SOLIDCodeisnt">fine-grained building blocks instead of course-grained building blocks</a>. Perhaps the only part you'll end up reusing is the core business logic contained in the check[Capacity] function. <a href="http://blog.ploeh.dk/2015/01/06/composition-root-reuse">Composition Roots aren't reusable</a>.
			</p>
			<p>
				(As an aside, you may think that if the check[Capacity] function is the only reusable part, then what's the point? This function is only a couple of lines long, so why even bother? That'd be a fair concern, if it wasn't for the context that all of this is only example code. Think of this example as a stand-in for much more complex business logic. Perhaps the restaurant will allow a certain percentage of over-booking, because some people never show up. Perhaps it will allow different over-booking percentages on different (week) days. Perhaps it'll need to handle reservations on per-table basis, instead of per-seat. Perhaps it'll need to handle multiple seatings on the same day. There are lots of variations you can throw into this business domain that will make it much more complex, and worthy of reuse.)
			</p>
			<p>
				<strong>Brittleness of composition</strong>
			</p>
			<p>
				Finally, you refer to a more realistic scenario, called <em>performOvernightCloseout</em>, and ask if a fine-grained composition wouldn't be brittle? In my experience, it wouldn't be <em>more</em> brittle than any alternatives I've identified. Whether you 'inject' functions into other functions, or you compose them in the Composition Root, doesn't change the underlying forces that act on your code. If you make substantial changes to the dependencies involved, it will break your code, and you'll need to address that. This is true for any manual composition, including <a href="http://blog.ploeh.dk/2014/06/10/pure-di">Pure DI</a>. The only way to avoid compilation errors when you redefine your dependency graphs is to use a DI Container, but that only <a href="http://blog.ploeh.dk/2011/04/29/Feedbackmechanismsandtradeoffs">makes the feedback loop worse, because it'd change a compile-time error into a run-time error</a>.
			</p>
			<p>
				This is a long answer, and even so, I'm not sure I've sufficiently addressed all of your concerns. If not, please write again for clarifications.
			</p>
		</div>
		<div class="comment-date">2016-03-30 13:46 UTC</div>



	</div>
    <div class="comment">
        <div class="comment-author">John Dailey</div>
        <div class="comment-content">
			<p>I believe there was a bit of miscommunication.  When I talked about the 'logic of only checking existing reservations on the same day", I wasn't talking about the implementation of the SqlGateway.  
	I was talking about the 'imp' function:
			</p>
			<pre>let imp =
	Validate.reservation
	>> map (fun r ->
		SqlGateway.getReservedSeats connectionString r.Date, r)
	>> bind (fun (i, r) -> Capacity.check 10 i r)
	>> map (SqlGateway.saveReservation connectionString)</pre>
		
			<p>
				This implements the logic of 'Validation comes first.  If that checks out, then get the number of reserved seats from the data store.  Use the date on the request
				for that.  Feed this into the capacity check routine and only if everything checks out should we persist the reservation.
			</p>

			<p>
				That's all internal logic that in my mind ought to be encapsulated within the domain.  That's what I meant by 'behind the wall'.  
				There should simply be a function 'makeReservation' with the signature ReservationRequest -> ReservationResponse.  That's it.  Clients should 
				not be worrying themselves with these extra details.  That 'imp' function just seems deeply inappropriate as something that lives externally to
				the reservations module, and that must be supplied individually by each client accessing the module.
			</p>

			<p>
				I guess I'm rejecting the idea of Onion/Hexagonal architecture, or at least the idea that all I/O always belongs at the outside.
				To me, a reservations module must depend on a reservations data store, because if you don't persist information to the db, <em>you haven't actually made the reservation</em>.
				Of course, I still want to depend on interfaces, not implementations (perhaps naming the reference ReservationDataStore.saveReservation).  The
				data store IS a separate layer and should have a well defined interface. 
			</p>
			<p>
				I just don't understand why anyone would find this design more desirable than the straightforward UI -> Logic -> Storage chain of dependencies.  Clearly there's some sort
				of appeal -- lots of smart people show excitement for it.  But it's a bit mystifying to me.
			</p>
		
		</div>
		<div class="comment-date">2016-04-06 01:45 UTC</div>
	</div>
</div>
