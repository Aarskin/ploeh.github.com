---
layout: post
title: "The Maybe functor"
date: 2017-06-21 13:12 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>A introduction to the Maybe functor for object-oriented programmers.</em>
	</p>
	<p>
		This article is an instalment in <a href="">an article series about functors</a>.
	</p>
	<p>
		One of the simplest, and easiest to understand, functors is <em>Maybe</em>. It's also sometimes known as the <em>Maybe monad</em>, but this is not a monad tutorial; it's a functor tutorial. Maybe is many things; one of them is a functor. In F#, Maybe is called <code>option</code>.
	</p>
	<p>
		<strong>Motivation</strong>
	</p>
	<p>
		Maybe enables you to model a value that may or may not be present. Object-oriented programmers typically have a hard time grasping the significance of Maybe, since it essentially does the same as <em>null</em> in object-oriented languages. There are differences, however. In languages like C# and Java, most things can be null, which can lead to much <a href="http://blog.ploeh.dk/2013/07/08/defensive-coding">defensive coding</a>. What happens more frequently, though, is that programmers forget to check for null, with run-time exceptions as the result.
	</p>
	<p>
		A Maybe value, on the other hand, makes it explicit that a value may or may not be present. In statically typed languages, it also forces you to deal with the case where no data is present; if you don't, your code will not compile. 
	</p>
	<p>
		Finally, in a language like C#, <a href="http://blog.ploeh.dk/2015/11/13/null-has-no-type-but-maybe-has">null has no type</a>, but a Maybe value always has a type.
	</p>
	<p>
		If you appreciate the tenet that <a href="https://www.python.org/dev/peps/pep-0020">explicit is better than implicit</a>, then you should favour Maybe over null.
	</p>
	<p>
		<strong>Implementation</strong>
	</p>
	<p>
		If you've read <a href="">the introduction</a>, then you know that <code>IEnumerable&lt;T&gt;</code> is a functor. In many ways, Maybe is like <code>IEnumerable&lt;T&gt;</code>, but it's a particular type of collection that can only contain zero or one element(s). There are various ways in which you can implement Maybe in an object-oriented language like C#; here's one:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Maybe</span>&lt;<span style="color:#2b91af;">T</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">internal</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;HasItem&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">internal</span>&nbsp;<span style="color:#2b91af;">T</span>&nbsp;Item&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Maybe()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.HasItem&nbsp;=&nbsp;<span style="color:blue;">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Maybe(<span style="color:#2b91af;">T</span>&nbsp;item)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(item&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(item));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.HasItem&nbsp;=&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.Item&nbsp;=&nbsp;item;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Maybe</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;Select&lt;<span style="color:#2b91af;">TResult</span>&gt;(<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">T</span>,&nbsp;<span style="color:#2b91af;">TResult</span>&gt;&nbsp;selector)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(selector&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(selector));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">this</span>.HasItem)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Maybe</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;(selector(<span style="color:blue;">this</span>.Item));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Maybe</span>&lt;<span style="color:#2b91af;">TResult</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">T</span>&nbsp;GetValueOrFallback(<span style="color:#2b91af;">T</span>&nbsp;fallbackValue)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(fallbackValue&nbsp;==&nbsp;<span style="color:blue;">null</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:blue;">nameof</span>(fallbackValue));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:blue;">this</span>.HasItem)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.Item;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;fallbackValue;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		This is a generic class with two constructors. The parameterless constructor indicates the case where no value is present, whereas the other constructor overload indicates the case where exactly one value is available. Notice that a guard clause prevents you from accidentally passing null as a value.
	</p>
	<p>
		The <code>Select</code> method has the correct signature for a functor. If a value is present, it uses the <code>selector</code> method argument to map <code>item</code> to a new value, and return a new <code>Maybe&lt;TResult&gt;</code> value. If no value is available, then a new empty <code>Maybe&lt;TResult&gt;</code> value is returned.
	</p>
	<p>
		A common question about such generic containers is: <em>how do you get the value out of the container?</em>
	</p>
	<p>
		The answer depends on the particular container, but in this example, I decided to enable that functionality with the <code>GetValueOrFallback</code> method. The only way to get the item out of a <code>Maybe</code> value is by supplying a fall-back value that can be used if no value is available. This is one way to guarantee that you, as a client developer, always to remember to deal with the empty case.
	</p>
	<p>
		<strong>Usage</strong>
	</p>
	<p>
		It's easy to use this <code>Maybe</code> class:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;source&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Maybe</span>&lt;<span style="color:blue;">int</span>&gt;(42);
</pre>
	</p>
	<p>
		This creates a new <code>Maybe&lt;int&gt;</code> object that contains the value <code>42</code>. If you need to change the value inside the object, you can, for example, do this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Maybe</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;dest&nbsp;=&nbsp;source.Select(x&nbsp;=&gt;&nbsp;x.ToString());
</pre>
	</p>
	<p>
		Since C# natively understands functors through its query syntax, you could also have written the above translation like this:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Maybe</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;dest&nbsp;=&nbsp;<span style="color:blue;">from</span>&nbsp;x&nbsp;<span style="color:blue;">in</span>&nbsp;source
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">select</span>&nbsp;x.ToString();</pre>
	</p>
	<p>
		It's up to you and your collaborators whether you prefer one or the other of those alternatives.
	</p>
	<p>
		A more realistic example could be as part of a line-of-business application. Many <a href="http://blog.ploeh.dk/2012/12/18/RangersandZookeepers">enterprise developers</a> are familiar with the <a href="https://martinfowler.com/eaaCatalog/repository.html">Repository pattern</a>. Imagine that you'd like to query a repository for a <code>Reservation</code> object. If one is found in the database, you'd like to convert it to a view model, so that you can display it.
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;viewModel&nbsp;=&nbsp;repository.Read(id)
&nbsp;&nbsp;&nbsp;&nbsp;.Select(r&nbsp;=&gt;&nbsp;r.ToViewModel())
&nbsp;&nbsp;&nbsp;&nbsp;.GetValueOrFallback(<span style="color:#2b91af;">ReservationViewModel</span>.Null);</pre>
	</p>
	<p>
		The repository's <code>Read</code> method returns <code>Maybe&lt;Reservation&gt;</code>, indicating that it's possible that no object is returned. This will happen if you're querying the repository for an <code>id</code> that doesn't exist in the underlying database.
	</p>
	<p>
		While you can translate the (potential) <code>Reservation</code> object to a view model (using the <code>ToViewModel</code> extension method), you'll have to supply a default view model to handle the case when the reservation wasn't found.
	</p>
	<p>
		<code>ReservationViewModel.Null</code> is a static read-only class field implementing the <a href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object pattern</a>. Here, it's used for the fall-back value, in case no object was returned from the repository.
	</p>
	<p>
		Notice that while you need a fall-back value at the end of your <a href="https://martinfowler.com/bliki/FluentInterface.html">fluent interface</a> pipeline, you don't need fall-back values for any intermediate steps. Furthermore, no defensive coding is required, because <code>Maybe&lt;T&gt;</code> guarantees that the object passed to <code>selector</code> is never <code>null</code>.
	</p>
	<p>
		<strong>Haskell</strong>
	</p>
	<p>
		In Haskell, Maybe is built in. You can create a <code>Maybe</code> value containing an integer like this (the type annotations are optional):
	</p>
	<p>
		<pre><span style="color:#600277;">source</span>&nbsp;::&nbsp;Maybe&nbsp;Int
source&nbsp;<span style="color:#666666;">=</span>&nbsp;Just&nbsp;<span style="color:#09885a;">42</span></pre>
</pre>
	</p>
	<p>
		Mapping <code>source</code> to a <code>String</code> can be done like this:
	</p>
	<p>
		<pre><span style="color:#600277;">dest</span>&nbsp;::&nbsp;Maybe&nbsp;String
dest&nbsp;<span style="color:#666666;">=</span>&nbsp;fmap&nbsp;show&nbsp;source</pre>
	</p>
	<p>
		It's also possible to use infix notation:
	</p>
	<p>
		<pre><span style="color:#600277;">dest</span>&nbsp;::&nbsp;Maybe&nbsp;String
dest&nbsp;<span style="color:#666666;">=</span>&nbsp;show&nbsp;<span style="color:#666666;">&lt;$&gt;</span>&nbsp;source</pre>
	</p>
	<p>
		The <code>&lt;$&gt;</code> operator is an alias for <code>fmap</code>.
	</p>
	<p>
		If you want to create an empty <code>Maybe</code> value, you use the <code>Nothing</code> constructor.
	</p>
	<p>
		<strong>F#</strong>
	</p>
	<p>
		Maybe is also a built-in type in F#, but here it's called <code>option</code> instead of <code>Maybe</code>. You create an option containing an integer like this:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;int&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;source&nbsp;=&nbsp;<span style="color:navy;">Some</span>&nbsp;42</pre>
	</p>
	<p>
		While the case where a value is present was denoted with <code>Just</code> in Haskell, in F# it's called <code>Some</code>.
	</p>
	<p>
		You can translate option values using the <code>map</code> function from the <code>Option</code> module:
	</p>
	<p>
		<pre><span style="color:green;">//&nbsp;string&nbsp;option</span>
<span style="color:blue;">let</span>&nbsp;dest&nbsp;=&nbsp;source&nbsp;|&gt;&nbsp;<span style="color:teal;">Option</span>.<span style="color:navy;">map</span>&nbsp;<span style="color:navy;">string</span></pre>
	</p>
	<p>
		Finally, if you want to create an empty <code>option</code> value, you can use the <code>None</code> case constructor.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Together with a functor called <em>Either</em>, Maybe is one of the workhorses of statically typed functional programming. You aren't going to write much F# or Haskell before you run into it. In C# I've used variations of the above <code>Maybe&lt;T&gt;</code> class for years, with much success.
	</p>
	<p>
		In this article, I only discussed Maybe in its role of being a functor, but it's so much more than that! It's also an applicative functor, a monad, and traversable (enumerable). Not all functors are that rich.
	</p>
	<p>
		<strong>Next:</strong> Tree.
	</p>
</div>