---
layout: post
title: "Object isomorphisms"
date: 2017-08-11 12:43
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>An object is equivalent to a product of functions. Alternative ways to look at objects.</em>
	</p>
	<p>
		This article is part of <a href="">a series of articles about software design isomorphisms</a>. So far, you've seen how to represent a single method or function in many different ways, but we haven't looked much at <em>objects</em> (in the object-oriented interpretation of the word).
	</p>
	<p>
		<strong>Objects as data with behaviour</strong>
	</p>
	<p>
		I often use the phrase that <em>objects are data with behaviour</em>. (I'm sure I didn't come up with this myself, but the source of the phrase escapes me.) In languages like C# and Java, objects are described by classes, and these often contain <em>class fields</em>. These fields constitute an instance's data, whereas its methods implement its behaviour.
	</p>
	<p>
		A class can contain an arbitrary number of fields, just like a method can take an arbitrary number of arguments. As demonstrated by the <a href="">argument list isomorphisms</a>, you can also represent an arbitrary number of arguments as a Parameter Object. The same argument can be applied to class fields. Instead of <em>n</em> fields, you can add a single 'data class' that holds all of these fields. In <a href="http://fsharp.org">F#</a> and <a href="https://www.haskell.org">Haskell</a> these are called <em>records</em>. You could also dissolve such a record to individual fields. That would be the inverse refactoring, so these representations are isomorphic.
	</p>
	<p>
		In other words, a class looks like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Class1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Data1</span>&nbsp;Data&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;<span style="color:blue;">set</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Out1</span>&nbsp;Op1(<span style="color:#2b91af;">In1</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Out2</span>&nbsp;Op2(<span style="color:#2b91af;">In2</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Out3</span>&nbsp;Op3(<span style="color:#2b91af;">In3</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;members...</span>
}</pre>
	</p>
	<p>
		Instead of an arbitrary number of fields, I've used the above isomorphism to represent data in a single <code>Data</code> property (Java developers: a C# property is a class field with public getter and setter methods).
	</p>
	<p>
		In this code example, I've deliberately kept the naming abstract. The purpose of this article series is to look at the shape of code, instead of what it does, or why. From argument list isomorphisms we know that we can represent any method as taking a single input value, and returning a single output value. The remaining work to be done in this article is to figure out what to do when there's more than a single method.
	</p>
	<p>
		<strong>Module</strong>
	</p>
	<p>
		From <a href="">function isomorphisms</a> we know that static methods are isomorphic to instance methods, as long as you include the original object as an extra argument. In this case, all data in <code>Class1</code> is contained in a single (mutable) <code>Data1</code> record, so we can eliminate <code>Class1</code> from the argument list in favour of <code>Data1</code>:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Class1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Out1</span>&nbsp;Op1(<span style="color:#2b91af;">Data1</span>&nbsp;data,&nbsp;<span style="color:#2b91af;">In1</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;data&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Out2</span>&nbsp;Op2(<span style="color:#2b91af;">Data1</span>&nbsp;data,&nbsp;<span style="color:#2b91af;">In2</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;data&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Out3</span>&nbsp;Op3(<span style="color:#2b91af;">Data1</span>&nbsp;data,&nbsp;<span style="color:#2b91af;">In3</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;data&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;Out1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;members...</span>
}</pre>
	</p>
	<p>
		Notice that <code>Class1</code> is now a <code>static</code> class. This simply means that it has no instance members, and if you try to add one, the C# compiler will complain.
	</p>
	<p>
		This is, in essence, a <em>module</em>. In F#, for example, a <code>module</code> is a static class that contains a collection of values and functions.
	</p>
	<p>
		<strong>Closures as behaviour with data</strong>
	</p>
	<p>
		As <em>data with behaviour</em>, objects are often passed around as input to methods. It's a convenient way to pass both data and associated behaviour (perhaps even with polymorphic dispatch) as a single thing. You'd be forgiven if you've looked at the above module-style refactoring and found it lacking in that regard.
	</p>
	<p>
		Nevertheless, function isomorphisms already demonstrated that you can solve this problem with closures. Imagine that you want to package all the static methods of <code>Class1</code> with a particular <code>Data1</code> value, and pass that 'package' as a single argument to another method. You can do that by closing over the value:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;data&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">Data1</span>&nbsp;{&nbsp;<span style="color:green;">/*&nbsp;initialize&nbsp;members&nbsp;here&nbsp;*/</span>&nbsp;};
<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">In1</span>,&nbsp;<span style="color:#2b91af;">Out1</span>&gt;&nbsp;op1&nbsp;=&nbsp;arg&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">Class1</span>.Op1(data,&nbsp;arg);
<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">In2</span>,&nbsp;<span style="color:#2b91af;">Out2</span>&gt;&nbsp;op2&nbsp;=&nbsp;arg&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">Class1</span>.Op2(data,&nbsp;arg);
<span style="color:#2b91af;">Func</span>&lt;<span style="color:#2b91af;">In3</span>,&nbsp;<span style="color:#2b91af;">Out3</span>&gt;&nbsp;op3&nbsp;=&nbsp;arg&nbsp;=&gt;&nbsp;<span style="color:#2b91af;">Class1</span>.Op3(data,&nbsp;arg);
<span style="color:green;">//&nbsp;More&nbsp;closures...</span></pre>
	</p>
	<p>
		First, you create a <code>Data1</code> value, and initialise it with your desired values. You then create <code>op1</code>, <code>op2</code>, and so on. These are functions that close over <code>data</code>; A.K.A. <em>closures</em>. Notice that they all close over the same variable. Also keep in mind here that I'm in no way pretending that <code>data</code> is immutable. That's not a requirement.
	</p>
	<p>
		Now you have <em>n</em> closures that all close over the same <code>data</code>. All you need to do is to package them into a single 'object':
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;objEq&nbsp;=&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(op1,&nbsp;op2,&nbsp;op3&nbsp;<span style="color:green;">/*&nbsp;more&nbsp;closures...&nbsp;*/</span>);
</pre>
	</p>
	<p>
		Once again, tuples are workhorses of software design isomorphisms. <code>objEq</code> is an 'object equivalent' consisting of closure; it's <em>behaviour with data</em>. You can now pass <code>objEq</code> as an argument to another method, if that's what you need to do.
	</p>
	<p>
		<strong>Isomorphism</strong>
	</p>
	<p>
		One common variation that I sometimes see is that instead of a tuple of functions, you can create a <em>record</em> of functions. This enables you to give each function a statically enforced name. In the theory of <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>, tuples and records are both <em>product types</em>, so when looking at the shape of code, these are closely related. Records also enable you to preserve the name of each method, so that this mapping from object to record of functions becomes lossless.
	</p>
	<p>
		The inverse mapping also exists. If you have a record of functions, you can refactor it to a class. You use the name of each record element as a method name, and the arguments and return types to further flesh out the methods.
	</p>
	<p>
		<strong>Conclusion</strong>
	</p>
	<p>
		To be clear, I'm not trying to convince you that it'd be great of you wrote all of your C# or Java using tuples of closures; it most likely wouldn't be. The point is that a class is isomorphic to a record of functions.
	</p>
	<p>
		From <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a>, and particular its application to Haskell, we know quite a bit about the properties of certain functions. Once we start to look at objects as tuples of functions, we may be able to say something about the properties of objects, because category theory also has something to say about the properties of tuples (for example that a tuple of <a href="">monoids</a> is itself a monoid).
	</p>
	<p>
		<strong>Next:</strong> Interface isomorphisms.
	</p>
</div>