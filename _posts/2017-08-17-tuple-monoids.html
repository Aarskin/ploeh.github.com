---
layout: post
title: "Tuple monoids"
date: 2017-08-17 9:44 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Tuples of monoids form monoids. An article for object-oriented programmers.</em>
	</p>
	<p>
		This article is part of a <a href="">series about monoids</a>. In short, a <em>monoid</em> is an associative binary operation with a neutral element (also known as <em>identity</em>).
	</p>
	<p>
		<strong>Tuples</strong>
	</p>
	<p>
		A tuple is a group of elements. In statically typed programming languages, each element has a type, and the types don't have to be the same. As an example, in C#, you can create a tuple like this:		
	</p>
	<p>
		<pre><span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;pair&nbsp;=&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(42,&nbsp;<span style="color:#a31515;">&quot;Foo&quot;</span>);
</pre>
	</p>
	<p>
		This creates a tuple where the first element must be an <code>int</code> and the second element a <code>string</code>. In the example, I've explicitly declared the type instead of using the <code>var</code> keyword, but this is only to make the type clearer (since you don't have an IDE in which to read the code).
	</p>
	<p>
		The <code>pair</code> tuple is a two-tuple, which means that it must have exactly two elements, of the types given, but you can also create larger tuples:
	</p>
	<p>
		<pre><span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;triad&nbsp;=&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(<span style="color:#a31515;">&quot;Bar&quot;</span>,&nbsp;<span style="color:blue;">false</span>,&nbsp;42);
</pre>
	</p>
	<p>
		This is a three-tuple, but conceptually, tuples can have any size.
	</p>
	<p>
		<strong>Pairs of monoids</strong>
	</p>
	<p>
		A <em>pair</em> (a two-tuple) forms a monoid if both elements form a monoid. <a href="https://www.haskell.org">Haskell</a> formalises this by stating:
	</p>
	<p>
		<code>instance (Monoid a, Monoid b) =&gt; Monoid (a, b)</code>
	</p>
	<p>
		The way to read this is that for any monoid <code>a</code> and any monoid <code>b</code>, the pair <code>(a, b)</code> is also a monoid.
	</p>
	<p>
		Perhaps this is easiest to understand with a C# example. Consider a tuple of the type <code>Tuple&lt;int, string&gt;</code>. Integers form monoids under both addition and multiplication, and <a href="">strings are monoids under concatenation</a>. Thus, you can make <code>Tuple&lt;int, string&gt;</code> form a monoid as well. For instance, use the multiplication monoid to define this binary operation:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;CombinePair(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;x,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(x.Item1&nbsp;*&nbsp;y.Item1,&nbsp;x.Item2&nbsp;+&nbsp;y.Item2);
}</pre>
	</p>
	<p>
		For this particular example, I've chosen multiplication as the binary operation for <code>int</code>, and the string concatenation operator <code>+</code> for <code>string</code>. The point is that since both elements are monoids, you can use their respective binary operations to return a new tuple with the combined values.
	</p>
	<p>
		This operation is associative, as the following <a href="https://fscheck.github.io/FsCheck">FsCheck</a> property demonstrates:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;CombinePairIsAssociative(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;x,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;y,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;z)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CombinePair(CombinePair(x,&nbsp;y),&nbsp;z),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CombinePair(x,&nbsp;CombinePair(y,&nbsp;z)));
}</pre>
	</p>
	<p>
		This property passes for all the <code>x</code>, <code>y</code>, and <code>z</code> values that FsCheck generates.
	</p>
	<p>
		The <code>CombinePair</code> operation has identity as well:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;PairIdentity&nbsp;=&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(1,&nbsp;(<span style="color:blue;">string</span>)<span style="color:blue;">null</span>);
</pre>
	</p>
	<p>
		Again, you can use the identity value for each of the elements in the tuple: <code>1</code> for the multiplication monoid, and <code>null</code> for string concatenation.
	</p>
	<p>
		This value behaves as the identity for <code>CombinePair</code>, at least for all non-null string values:
	</p>
	<p>
		<pre>[<span style="color:#2b91af;">Property</span>(QuietOnSuccess&nbsp;=&nbsp;<span style="color:blue;">true</span>)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;CombinePairHasIdentity(<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">int</span>,&nbsp;<span style="color:#2b91af;">NonNull</span>&lt;<span style="color:blue;">string</span>&gt;&gt;&nbsp;seed)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;x&nbsp;=&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(seed.Item1,&nbsp;seed.Item2.Get);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(CombinePair(PairIdentity,&nbsp;x),&nbsp;CombinePair(x,&nbsp;PairIdentity));
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Assert</span>.Equal(x,&nbsp;CombinePair(x,&nbsp;PairIdentity));
}</pre>
	</p>
	<p>
		Again, this test passes for all <code>seed</code> values generated by FsCheck.
	</p>
	<p>
		The C# code here is only an example, but I hope it's clear how the result generalises.
	</p>
	<p>
		<strong>Triads of monoids</strong>
	</p>
	<p>
		In the above section, you saw how pairs of monoids form a monoid. Not surprisingly, triads of monoids also form monoids. Here's another C# example:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;CombineTriad(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;x,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;y)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:#2b91af;">Tuple</span>.Create(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Item1&nbsp;+&nbsp;y.Item1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Item2&nbsp;||&nbsp;y.Item2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.Item3&nbsp;*&nbsp;y.Item3);
}</pre>
	</p>
	<p>
		The <code>CombineTriad</code> method is another binary operation. This time it combines two triads to a single triad. Since both <code>string</code>, <code>bool</code>, and <code>int</code> form monoids, it's possible to combine each element in the two tuples to create a new tuple. There's more than one monoid for integers, and the same goes for Boolean values, but here I've chosen multiplication and Boolean <em>or</em>, so the identity is this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Tuple</span>&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;TriadIdentity&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Tuple</span>.Create((<span style="color:blue;">string</span>)<span style="color:blue;">null</span>,&nbsp;<span style="color:blue;">false</span>,&nbsp;1);</pre>
	</p>
	<p>
		This triad simply contains the identities for string concatenation, Boolean <em>or</em>, and multiplication. The operation is associative, but I'm not going to show this with a property-based test. Both tests for associativity and identity are similar to the above tests; you could consider writing them as an exercise, if you'd like.
	</p>
	<p>
		This triad example only demonstrates a particular triad, but you can find the generalisation in Haskell:
	</p>
	<p>
		<pre>instance (Monoid a, Monoid b, Monoid c) =&gt; Monoid (a, b, c)</pre>
	</p>
	<p>
		This simply states that for monoids <code>a</code>, <code>b</code>, and <code>c</code>, the tuple <code>(a, b, c)</code> is also a monoid.
	</p>
	<p>
		<strong>Generalisation</strong>
	</p>
	<p>
		At this point, it can hardly come as a surprise that quads and pentuples of monoids are also monoids. From Haskell:
	</p>
	<p>
		<pre>instance (Monoid a, Monoid b, Monoid c, Monoid d) =&gt; Monoid (a, b, c, d)
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =&gt; Monoid (a, b, c, d, e)</pre>
	</p>
	<p>
		The Haskell standard library stops at pentuples (five-tuples), because it has to stop somewhere, but I'm sure you can see how this is a general rule.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Tuples of monoids are also monoids. This holds for tuples of any size, but all of the elements has to be monoids.
	</p>
	<p>
		<strong>Next:</strong> Function monoids.
	</p>
</div>