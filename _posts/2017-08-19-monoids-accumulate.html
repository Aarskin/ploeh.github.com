---
layout: post
title: "Monoids accumulate"
date: 2017-08-19 6:42 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>You can accumulate an arbitrary number of monoids to a single value. An article for object-oriented programmers.</em>
	</p>
	<p>
		This article is part of a <a href="">series about monoids</a>. In short, a <em>monoid</em> is an associative binary operation with a neutral element (also known as <em>identity</em>).
	</p>
	<p>
		Recall that a binary operation is an operation involving two arguments of the same type, and returning a value of that type.		
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Foo</span>&nbsp;Op(<span style="color:#2b91af;">Foo</span>&nbsp;x,&nbsp;<span style="color:#2b91af;">Foo</span>&nbsp;y)</pre>
	</p>
	<p>
		Notice that such an operation reduces two <code>Foo</code> values to a single <code>Foo</code> value.
	</p>
	<p>
		<strong>Accumulation</strong>
	</p>
	<p>
		Since you have an operation that can reduce two values to a single value, you can use that single value as the input for yet another binary operation. This enables you to accumulate, or aggregate, an arbitrary number of values.
	</p>
	<p>
		Consider the instance variation of the above <code>Op</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Foo</span>&nbsp;Op(<span style="color:#2b91af;">Foo</span>&nbsp;foo)</pre>
	</p>
	<p>
		This is another representation of the operation, but instead of being a static method, it's an instance method on the <code>Foo</code> class.
	</p>
	<p>
		When <code>Op</code> is a monoid, you can easily write a function that accumulates an arbitrary number of <code>Foo</code> values:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">Foo</span>&nbsp;Accumulate(<span style="color:#2b91af;">IReadOnlyCollection</span>&lt;<span style="color:#2b91af;">Foo</span>&gt;&nbsp;foos)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;acc&nbsp;=&nbsp;Identity;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;f&nbsp;<span style="color:blue;">in</span>&nbsp;foos)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;acc&nbsp;=&nbsp;acc.Op(f);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;acc;
}</pre>
	</p>
	<p>
		You start with the <code>Identity</code> value, which also becomes the return value if <code>foos</code> is empty. Then you simply loop over each value in <code>foos</code> and use <code>Op</code> with the value accumulated so far (<code>acc</code>) and the current element in the sequence.
	</p>
	<p>
		Once you're done looping, you return the accumulator.
	</p>
	<p>
		<strong>Generalisation</strong>
	</p>
	<p>
		You can do this with any monoid. In <a href="https://www.haskell.org">Haskell</a>, this function is called <code>mconcat</code>, and it has this type:
	</p>
	<p>
		<pre>mconcat :: Monoid a =&gt; [a] -&gt; a</pre>
	</p>
	<p>
		The way you can read this is that for any monoid <code>a</code>, <code>mconcat</code> is a function that takes a linked list of <code>a</code> values as input, and returns a single <code>a</code> value as output.
	</p>
	<p>
		This function seems both more general, and more constrained, than the above C# example. It's more general than the C# example because it works on any monoid, instead of just <code>Foo.Op</code>. On the other hand, it seems more limited because it works only on Haskell lists. The C# example, in contrast, can accumulate any <code>IReadOnlyCollection&lt;Foo&gt;</code>. Could you somehow combine those two generalisations?
	</p>
	<p>
		Nothing stops you from doing that, but it's already in Haskell's <code>Data.Foldable</code> module:
	</p>
	<p>
		<pre>fold :: (Monoid m, Foldable t) =&gt; t m -&gt; m</pre>
	</p>
	<p>
		The way to read this is that there's a function called <code>fold</code>, and it accumulates any monoid <code>m</code> contained in any 'foldable' data container <code>t</code>. That a data container is 'foldable' means that there's a way to somehow fold, or aggregate, the element(s) in the container to a value.
	</p>
	<p>
		Linked lists, arrays, and other types of sequences are foldable, as are <a href="">Maybe</a> and <a href="">trees</a>.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		You can accumulate an arbitrary number of monoidal values as long as they're held in a container that enable you to 'fold' it. This includes all sorts of lists and arrays.
	</p>
	<p>
		This article concludes the article series about monoids. In the next series of articles, you'll learn about a related category of operations.
	</p>
	<p>
		<strong>Next: </strong> Semigroups.
	</p>
</div>