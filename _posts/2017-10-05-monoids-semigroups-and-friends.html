---
layout: post
title: "Monoids, semigroups, and friends"
date: 2017-10-05 8:24 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Introduction to monoids, semigroups, and similar concepts, for object-oriented programmers.</em>
	</p>
	<p>
		This article series is part of <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">an even larger series of articles about the relationship between design patterns and category theory.</a>
	</p>
	<p>
		Functional programming has often been criticised for its abstruse jargon. Terminology like <em>zygohistomorphic prepromorphism</em> doesn't help sell the message, but before we start throwing stones, we should first exit our own glass house. In object-oriented design, we have names like <a href="https://en.wikipedia.org/wiki/Bridge_pattern">Bridge</a>, <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>, <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>, <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">cohesion</a>, and so on. The words sound familiar, but can you actually explain or implement the Visitor design pattern, or characterise cohesion?
	</p>
	<p>
		That <em>Bridge</em> is a word you know doesn't make object-oriented terminology better. Perhaps it even makes it worse. After all, now the word has become ambiguous: did you mean a physical structure connecting two places, or are you talking about the design pattern? Granted, in practical use, it will often be clear from the context, but it doesn't change that if someone talks about the Bridge pattern, you'll have no idea what it is, unless you've actually learned it. Thus, that the word is familiar doesn't make it better.
	</p>
	<p>
		More than one object-oriented programmer have extolled the virtues of 'operations whose return type is the same as the type of its argument(s)'. Such vocabulary, however, is inconvenient. Wouldn't it be nice to have a single, well-defined word for this? Perhaps <em>monoid</em>, or <em>semigroup?</em>
	</p>
	<p>
		<strong>Object-oriented hunches</strong>
	</p>
	<p>
		In <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a>, Eric Evans discusses the notion of <em>Closure of Operations</em>, that is, operations "whose return type is the same as the type of its argument(s)." In C#, it could be a method with the signature <code>public Foo Bar(Foo f1, Foo f2)</code>. This method takes two <code>Foo</code> objects as input, and returns a new <code>Foo</code> object as output.
	</p>
	<p>
		As Evans points out, object designs with that quality begins to look like arithmetic. If you have an operation that takes two <code>Foo</code> and returns a <code>Foo</code>, what could it be? Could it be like addition? Multiplication? Another mathematical operation?
	</p>
	<p>
		Some <a href="http://blog.ploeh.dk/2012/12/18/RangersandZookeepers">enterprise developers</a> just 'want to get stuff done', and don't care about mathematics. To them, the value of making code more mathematical is disputable. Still, even if you 'don't like maths', you understand addition, multiplication, and so on. Arithmetic is a powerful metaphor, because all programmers understand it.
	</p>
	<p>
		In his book <a href="http://bit.ly/tddbe">Test-Driven Development: By Example</a>, Kent Beck seems to have the same hunch, although I don't think he ever explicitly calls it.
	</p>
	<p>
		What Evans describes are monoids, semigroups, and similar concepts from abstract algebra. To be fair, I recently had the opportunity to discuss the matter with him, and he's perfectly aware of those concepts today. Whether he was aware of them when he wrote DDD in 2003 I don't know, but I certainly wasn't; my errand isn't to point fingers, but to point out that clever people have found this design principle valuable in object-oriented design long before they gave it a distinct name.
	</p>
	<p>
		<strong>Relationships</strong>
	</p>
	<p>
		Monoids and semigroups belong to a larger group of operations called <em>magmas</em>. You'll learn about those later, but we'll start with monoids, move on to semigroups, and then explore other magmas. All monoids are semigroups, while the converse doesn't hold. In other words, monoids form a subset of semigroups.
	</p>
	<p>
		<img src="/content/binary/magmas-quasigroups-semigroups-monoids.png" alt="Monoids are a subset of semigroups, and part of the larger magma set.">
	</p>
	<p>
		All magmas describe binary operations of the form: an operation takes two <code>Foo</code> values as input and returns a <code>Foo</code> value as output. Both categories are governed by (intuitive) laws. The difference is that the laws governing monoids are stricter than the laws governing semigroups. Don't be put off by the terminology; 'law' may sound like you have to get involved in complicated maths, but these laws are simple and intuitive. You'll learn them as you read on.
		<ul>
			<li>Monoids
				<ul>
					<li>Strings, lists, and sequences as a monoid</li>
					<li>Money monoid</li>
					<li>Convex hull monoid</li>
					<li>Tuple monoids</li>
					<li>Function monoids</li>
					<li>Endomorphism monoid</li>
					<li>Monoids accumulate</li>
				</ul>
			</li>
			<li>Semigroups
				<ul>
					<li>Bounding box semigroup</li>
				</ul>
			</li>
			<li>Quasigroups</li>
			<li>Magmas
				<ul>
					<li>Rock Paper Scissors magma</li>
					<li>Colour-mixing magma</li>
				</ul>
			</li>
		</ul>
		While they seem firmly rooted in mathematics, these categories offer insights into object-oriented design as well. More on that later.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		To the average object-oriented programmer, terms like <em>monoid</em> and <em>semigroup</em> smell of mathematics, academia, and ivory-tower astronaut architects, but they're plain and simple concepts that anyone can understand, if they wish to invest 15 minutes of their time.
	</p>
	<p>
		Whether or not an object is a <em>magma</em> tells us whether Evans' <em>Closure of Operations</em> is possible. It might teach us other things about our code, as well.
	</p>
	<p>
		<strong>Next: </strong> Monoids.
	</p>
</div>