---
layout: post
title: "Monoids, semigroups, and friends"
date: 2017-10-05 8:24 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Introduction to monoids, semigroups, and similar concepts, for object-oriented programmers.</em>
	</p>
	<p>
		This article series is part of <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">an even larger series of articles about the relationship between design patterns and category theory.</a>
	</p>
	<p>
		Functional programming has often been criticised for its abstruse jargon. Terminology like <em>zygohistomorphic prepromorphism</em> doesn't help sell the message, but before we start throwing stones, we should first exit our own glass house. In object-oriented design, we have names like <a href="https://en.wikipedia.org/wiki/Bridge_pattern">Bridge</a>, <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>, <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>, <a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">cohesion</a>, and so on. The words sound familiar, but can you actually explain or implement the Visitor design pattern, or characterise cohesion?
	</p>
	<p>
		That <em>Bridge</em> is a word you know doesn't make object-oriented terminology better. Perhaps it even makes it worse. After all, now the word has become ambiguous: did you mean a physical structure connecting two places, or are you talking about the design pattern? Granted, in practical use, it will often be clear from the context, but it doesn't change that if someone talks about the Bridge pattern, you'll have no idea what it is, unless you've actually learned it. Thus, that the word is familiar doesn't make it better.
	</p>
	<p>
		More than one object-oriented programmer have extolled the virtues of 'operations whose return type is the same as the type of its argument(s)'. Such vocabulary, however, is inconvenient. Wouldn't it be nice to have a single, well-defined word for this? Perhaps <em>monoid</em>, or <em>semigroup?</em>
	</p>
	<p>
		<strong>Object-oriented hunches</strong>
	</p>
	<p>
		In <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a>, Eric Evans discusses the notion of <em>Closure of Operations</em>, that is, operations "whose return type is the same as the type of its argument(s)." In C#, it could be a method with the signature <code>public Foo Bar(Foo f1, Foo f2)</code>. This method takes two <code>Foo</code> objects as input, and returns a new <code>Foo</code> object as output.
	</p>
	<p>
		As Evans points out, object designs with that quality begins to look like arithmetic. If you have an operation that takes two <code>Foo</code> and returns a <code>Foo</code>, what could it be? Could it be like addition? Multiplication? Another mathematical operation?
	</p>
	<p>
		Some <a href="http://blog.ploeh.dk/2012/12/18/RangersandZookeepers">enterprise developers</a> just 'want to get stuff done', and don't care about mathematics. To them, the value of making code more mathematical is disputable. Still, even if you 'don't like maths', you understand addition, multiplication, and so on. Arithmetic is a powerful metaphor, because all programmers understand it.
	</p>
	<p>
		In his book <a href="http://bit.ly/tddbe">Test-Driven Development: By Example</a>, Kent Beck seems to have the same hunch, although I don't think he ever explicitly calls it out.
	</p>
	<p>
		What Evans describes are monoids, semigroups, and similar concepts from abstract algebra. To be fair, I recently had the opportunity to discuss the matter with him, and he's perfectly aware of those concepts today. Whether he was aware of them when he wrote DDD in 2003 I don't know, but I certainly wasn't; my errand isn't to point fingers, but to point out that clever people have found this design principle valuable in object-oriented design long before they gave it a distinct name.
	</p>
	<p>
		<strong>Relationships</strong>
	</p>
	<p>
		Monoids and semigroups belong to a larger group of operations called <em>magmas</em>. You'll learn about those later, but we'll start with monoids, move on to semigroups, and then explore other magmas. All monoids are semigroups, while the inverse doesn't hold. In other words, monoids form a subset of semigroups.
	</p>
	<p>
		<img src="/content/binary/magmas-quasigroups-semigroups-monoids.png" alt="Monoids are a subset of semigroups, and part of the larger magma set.">
	</p>
	<p>
		All magmas describe binary operations of the form: an operation takes two <code>Foo</code> values as input and returns a <code>Foo</code> value as output. Both categories are governed by (intuitive) laws. The difference is that the laws governing monoids are stricter than the laws governing semigroups. Don't be put off by the terminology; 'law' may sound like you have to get involved in complicated maths, but these laws are simple and intuitive. You'll learn them as you read on.
		<ul>
			<li><a href="http://blog.ploeh.dk/2017/10/06/monoids">Monoids</a>
				<ul>
					<li>Strings, lists, and sequences as a monoid</li>
					<li>Money monoid</li>
					<li>Convex hull monoid</li>
					<li>Tuple monoids</li>
					<li>Function monoids</li>
					<li>Endomorphism monoid</li>
					<li>Monoids accumulate</li>
				</ul>
			</li>
			<li>Semigroups
				<ul>
					<li>Bounding box semigroup</li>
				</ul>
			</li>
			<li>Quasigroups</li>
			<li>Magmas
				<ul>
					<li>Rock Paper Scissors magma</li>
					<li>Colour-mixing magma</li>
				</ul>
			</li>
		</ul>
		While they seem firmly rooted in mathematics, these categories offer insights into object-oriented design as well. More on that later.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		To the average object-oriented programmer, terms like <em>monoid</em> and <em>semigroup</em> smell of mathematics, academia, and ivory-tower astronaut architects, but they're plain and simple concepts that anyone can understand, if they wish to invest 15 minutes of their time.
	</p>
	<p>
		Whether or not an object is a <em>magma</em> tells us whether Evans' <em>Closure of Operations</em> is possible. It might teach us other things about our code, as well.
	</p>
	<p>
		<strong>Next: </strong> <a href="http://blog.ploeh.dk/2017/10/06/monoids">Monoids</a>.
	</p>
</div>

<div id="comments">
	<hr />
	<h2 id="comments-header">Comments</h2>
	<div class="comment">
		<div class="comment-author">
			<a href="https://megakemp.com">Enrico Campidoglio</a>
		</div>
		<div class="comment-content">
			<p>Hi Mark,</p>

			<p>Thank you for taking the time to write such interesting articles. I'm personally fascinated by the relationship between ancient subjects like algebra and modern ones like programming. I can't wait to read more.</p>

			<p>That said, I understand the feeling of being put off by some of the terms used in functional programming (I'm looking at you, "<em>zygohistomorphic</em>"). I think the reason for it is that the vast majority of those words come from Greek or Latin, and to many people (me included) Greek is exactly what it sounds like — <a href="https://en.wikipedia.org/wiki/Greek_to_me">Greek</a>.</p>

			<p>Granted, things aren't much better in the object-oriented programming world, where a <em>Visitor</em> isn't necessarily what you think it is, even if you recognize the word.</p>

			<p>However, in my experience, knowing the etymology of a word is the first step in understanding it. I think that including a translation for every new term would make the subjects of these articles feel less alien. It would be a way to "break the ice", so to speak.</p>

			<p>One example I came to think of is the word <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)"><em>polymorphism</em></a> — perhaps one of the most "academic-sounding" words thrown around in object-oriented programming conversations. It may feel intimidating at first, but it quickly falls off the ivory tower once you know that it literally means "when things can take many shapes" (from the Greek <em>polys</em>, "many", <em>morphē</em>, "shape" and "<em>ismós</em>", the general concept).</p>

			<p>/Enrico</p>
		</div>
		<div class="comment-date">2017-10-05 12:24 UTC</div>
	</div>

	<div class="comment">
		<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Enrico, thank you for writing. Funny you should write that, because leading with an explanation of <em>monoid</em> is exactly what I do in my new <a href="https://cleancoders.com">Clean Coders</a> episode <a href="https://cleancoders.com/episode/humane-code-real-episode-2/show">Composite as Universal Abstraction</a>. In short, <em>monoid</em> means 'one-like'. In the video, I go into more details on why that's a useful name.
			</p>
		</div>
		<div class="comment-date">2017-10-08 8:06 UTC</div>
	</div>
</div>
