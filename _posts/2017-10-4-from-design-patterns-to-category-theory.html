---
layout: post
title: "From design patterns to category theory"
date: 2017-10-4 10:43 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>How do you design good abstractions? By using abstractions that already exist.</em>
	</p>
	<p>
		When I was a boy, I had a <a href="https://en.wikipedia.org/wiki/Cassette_deck">cassette tape player</a>. It came with playback controls like these:
	</p>
	<p>
		<img src="/content/binary/playback-controls.png" alt="Rewind, play/pause, and fast forward symbols.">
	</p>
	<p>
		Soon after cassette players had become widely adopted, <a href="https://en.wikipedia.org/wiki/Videocassette_recorder">VCR</a> manufacturers figured out that they could reuse those symbols to make their machines easier to use. Everyone could play a video tape, but 'no one' could 'program' them, because, while playback controls were already universally understood by consumers, each VCR came with its own proprietary interface for 'programming'.
	</p>
	<p>
		Then came <a href="https://en.wikipedia.org/wiki/CD_player">CD players</a>. Same controls.
	</p>
	<p>
		MP3 players. Same controls.
	</p>
	<p>
		Streaming audio and video players. Same controls.
	</p>
	<p>
		If you download an app that plays music, odds are that you'll find it easy to get started playing music. One reason is that all playback apps seem to have the same common set of controls. It's an abstraction that you already know.
	</p>
	<p>
		<strong>Understanding source code</strong>
	</p>
	<p>
		As I explain in my <a href="https://cleancoders.com/episode/humane-code-real-episode-1/show">Humane Code</a> video, you can't program without abstractions. To summarise, in <a href="http://amzn.to/19W4JHk">the words of Robert C. Martin</a>
		<blockquote>
			"Abstraction is the elimination of the irrelevant and the amplification of the essential"
		</blockquote>
		With such abstractions, source code becomes easier to understand. Like everything else, there's no silver bullet, but good coding abstractions can save you much grief, and make it easier to understand big and complex code bases.
	</p>
	<p>
		Not only can a good abstraction shield you from having to understand all the details in a big system, but if you're familiar with the abstraction, you may be able to quickly get up to speed.
	</p>
	<p>
		While the above definition is great for identifying a good abstraction, it doesn't tell you how to create one.
	</p>
	<p>
		<strong>Design patterns</strong>
	</p>
	<p>
		<a href="http://amzn.to/XBYukB">Design Patterns</a> explains that a design pattern is a general reusable solution to a commonly occurring problem. As I interpret the original intent of the Gang of Four, the book was an attempt to collect and abstract solutions that were repeatedly observed 'in the wild'. The design patterns in the book are <em>descriptive</em>, not prescriptive.
	</p>
	<p>
		Design patterns are useful in two ways:
		<ul>
			<li>They offer solutions</li>
			<li>They form a vocabulary</li>
		</ul>
		In my opinion, however, people often overlook the second advantage. Programmers are often eager to find <em>solutions</em>. "I have a problem; what's the solution? Oh, here's a design pattern that fits!"
	</p>
	<p>
		I have no problems with ready-made solutions, but I think that the other advantage may be even bigger. When you're looking at unfamiliar source code, you struggle to understand how it's structured, and what it does. If, hypothetically, you discover that pieces of that unfamiliar source code follows a design pattern that you know, then understanding the code becomes much easier.
	</p>
	<p>
		There are two criteria for this to happen:
		<ul>
			<li>The reader (you) must already know the pattern</li>
			<li>The original author (also you?) must have implemented the pattern without any surprising deviations</li>
		</ul>
		As a programmer (code author), you can help readers (users) of your code. Don't use every design pattern in the book, but when you use one, make it as obvious to the reader as you can: Use the terminology, class names, and so on from the book. Add comments where your naming deviates. Add links that the novice user can follow to learn more.
	</p>
	<p>
		<strong>Ambiguous specification</strong>
	</p>
	<p>
		Programming to a well-known abstraction is a force multiplier, but it does require that those two conditions are satisfied: prior knowledge, and correct implementation.
	</p>
	<p>
		I don't know how to solve the <em>prior knowledge</em> requirement, other than to tell you to study. I do, however, think that it's possible to formalise some of the known design patterns.
	</p>
	<p>
		Most design patterns are described in some depth. They come with sections on motivation, when to use and not to use, diagrams, and example code. Furthermore, they also come with an overview of <em>variations</em>.
	</p>
	<p>
		Picture this: as a reader, you've just identified that the code you're looking at is an implementation of a design pattern. Then you realise that it isn't structured like you'd expect, or that its behaviour surprises you. Was the author incompetent, after all?
	</p>
	<p>
		While you're inclined to believe the worst about your fellow (wo)man, you look up the original pattern, and there it is: the author is using a variation of the pattern.
	</p>
	<p>
		Design patterns are ambiguous.
	</p>
	<p>
		<strong>Universal abstractions</strong>
	</p>
	<p>
		<em>Design Patterns</em> was a great effort in 1994, and I've personally benefited from it. The catalogue was an attempt to discover good abstractions.
	</p>
	<p>
		What's a good abstraction? As already quoted, it's a model that amplifies the essentials, etcetera. I think a good abstraction should also be <em>intuitive</em>.
	</p>
	<p>
		What's the most intuitive abstractions ever?
	</p>
	<p>
		Mathematics.
	</p>
	<p>
		Stay with me, please. If you're a normal reader of my blog, you're most likely an 'industry programmer' or <a href="http://blog.ploeh.dk/2012/12/18/RangersandZookeepers">enterprise developer</a>. You're not interested in mathematics. Perhaps mathematics even turns you off, and at the very least, you never had use for mathematics in programming.
	</p>
	<p>
		You may not find <em>n</em>-dimensional <a href="https://en.wikipedia.org/wiki/Differential_topology">differential topology</a>, or <a href="https://en.wikipedia.org/wiki/Stochastic_calculus">stochastic calculus</a>, intuitive, but that's not the kind of mathematics I have in mind.
	</p>
	<p>
		Basic arithmetic is intuitive. You know: <em>1 + 3 = 4</em>, or <em>3 * 4 = 12</em>. In fact, it's <em>so intuitive</em> that you can't formally prove it -without <a href="https://en.wikipedia.org/wiki/Axiom">axioms</a>, that is. <a href="https://en.wikipedia.org/wiki/Peano_axioms">These axioms</a> are unprovable; you must take them at face value, but you'll readily do that because they're <em>so intuitive</em>.
	</p>
	<p>
		Mathematics is a big structure, but it's all based on intuitive axioms. Mathematics is intuitive.
	</p>
	<p>
		Writers before me have celebrated the power of mathematical abstraction in programming. For instance, in <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a> Eric Evans discusses how <em>Closure of Operations</em> leads to object models reminiscent of arithmetic. If you can design <a href="https://martinfowler.com/bliki/ValueObject.html">Value Objects</a> in such a way that you can somehow 'add' them together, you have an intuitive and powerful abstraction.
	</p>
	<p>
		Notice that there's more than one way to combine numbers. You can add them together, but you can also multiply them. Could there be a common abstraction for that? What about objects that can somehow be combined, even if they aren't 'number-like'? The generalisation of such operations is a branch of mathematics called <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a>, and it has turned out to be productive when applied to functional programming. <a href="https://www.haskell.org">Haskell</a> is the most prominent example.
	</p>
	<p>
		By an interesting coincidence, the 'things' in category theory are called <em>objects</em>, and while they aren't objects in the sense that we think of in object-oriented design, there <em>is</em> some equivalence. Category theory concerns itself with how objects map to other objects. A functional programmer would interpret such <em>morphisms</em> as functions, but in a sense, you can also think of them as well-defined behaviour that's associated with data.
	</p>
	<p>
		The objects of category theory are universal abstractions. Some of them, it turns out, coincide with known design patterns. The difference is, however, that category theory concepts are governed by specific laws. In order to be a functor, for example, an object must obey certain simple and intuitive laws. This makes the category theory concepts more specific, and less ambiguous, than design patterns.
	</p>
	<p>
		The coming article series is an exploration of this space:
		<ul>
			<li><a href="http://blog.ploeh.dk/2017/10/05/monoids-semigroups-and-friends">Monoids, semigroups, and friends</a>
				<ul>
					<li><a href="http://blog.ploeh.dk/2017/10/06/monoids">Monoids</a>
						<ul>
							<li><a href="http://blog.ploeh.dk/2017/10/10/strings-lists-and-sequences-as-a-monoid">Strings, lists, and sequences as a monoid</a></li>
							<li><a href="http://blog.ploeh.dk/2017/10/16/money-monoid">Money monoid</a></li>
							<li><a href="http://blog.ploeh.dk/2017/10/23/convex-hull-monoid">Convex hull monoid</a></li>
							<li><a href="http://blog.ploeh.dk/2017/10/30/tuple-monoids">Tuple monoids</a></li>
							<li><a href="http://blog.ploeh.dk/2017/11/06/function-monoids">Function monoids</a></li>
							<li><a href="http://blog.ploeh.dk/2017/11/13/endomorphism-monoid">Endomorphism monoid</a></li>
							<li><a href="http://blog.ploeh.dk/2017/11/20/monoids-accumulate">Monoids accumulate</a></li>
						</ul>
					</li>
					<li><a href="http://blog.ploeh.dk/2017/11/27/semigroups">Semigroups</a>
						<ul>
							<li><a href="http://blog.ploeh.dk/2017/12/04/bounding-box-semigroup">Bounding box semigroup</a></li>
							<li><a href="http://blog.ploeh.dk/2017/12/11/semigroups-accumulate">Semigroups accumulate</a></li>
						</ul>
					</li>
					<li><a href="http://blog.ploeh.dk/2017/12/18/quasigroups">Quasigroups</a></li>
					<li><a href="http://blog.ploeh.dk/2017/12/27/magmas">Magmas</a>
						<ul>
							<li><a href="http://blog.ploeh.dk/2017/12/28/rock-paper-scissors-magma">Rock Paper Scissors magma</a></li>
							<li><a href="http://blog.ploeh.dk/2018/01/02/colour-mixing-magma">Colour-mixing magma</a></li>
						</ul>
					</li>
				</ul>
			</li>
			<li><a href="http://blog.ploeh.dk/2018/01/08/software-design-isomorphisms">Software design isomorphisms</a>
				<ul>
					<li><a href="http://blog.ploeh.dk/2018/01/15/unit-isomorphisms">Unit isomorphisms</a></li>
					<li><a href="http://blog.ploeh.dk/2018/01/22/function-isomorphisms">Function isomorphisms</a></li>
					<li><a href="http://blog.ploeh.dk/2018/01/29/argument-list-isomorphisms">Argument list isomorphisms</a></li>
					<li><a href="http://blog.ploeh.dk/2018/02/05/uncurry-isomorphisms">Uncurry isomorphisms</a></li>
					<li><a href="http://blog.ploeh.dk/2018/02/12/object-isomorphisms">Object isomorphisms</a></li>
					<li><a href="http://blog.ploeh.dk/2018/02/19/abstract-class-isomorphism">Abstract class isomorphism</a></li>
					<li><a href="http://blog.ploeh.dk/2018/02/26/inheritance-composition-isomorphism">Inheritance-composition isomorphism</a></li>
				</ul>
			</li>
			<li>From specific patterns to category theory
				<ul>
					<li>Composite as a monoid</li>
					<li>Coalescing Composite as a monoid</li>
					<li>Endomorphic Composite as a monoid</li>
					<li>Null Object as identity</li>
				</ul>
			</li>
		</ul>
		I believe that learning about these universal abstractions is the next step in software design. If you know design patterns, you have a vocabulary, but the details are still open to interpretation. If you know category theory, you have a better vocabulary. Just like design patterns, you have to learn these things, but once you've learned them, you've learned something that transcends a particular software library, a particular framework, a particular programming language. Learning about functors, monoids, and so on, is a good investment, because these concepts are rooted in mathematics, not any particular technology.
	</p>
	<p>
		<strong>Motivation</strong>
	</p>
	<p>
		The purpose of this article series is two-fold. Depending on your needs and interests, you can use it to
		<ul>
			<li>learn better abstractions</li>
			<li>learn how functional programming is a real alternative to object-oriented programming</li>
		</ul>
		You've already read how it's in your interest to learn universal abstractions. It'll make your code clearer, more concise, and you'll have a better software design vocabulary.
	</p>
	<p>
		The other goal of these articles may be less clear. Object-oriented programming (OOP) is the dominant software design <a href="https://en.wikipedia.org/wiki/Paradigm">paradigm</a>. It wasn't always so. When OOP was new, many veteran programmers couldn't see how it could be useful. They were schooled in one paradigm, and it was difficult for them to shift to the new paradigm. They were used to do things in one way (typically, procedural), and it wasn't clear how to achieve the same goals with idiomatic object-oriented design.
	</p>
	<p>
		The same sort of resistance applies to functional programming. Tasks that are easy in OOP seem impossible in functional programming. How do you make a <em>for</em> loop? How do you change state? How do you break out of a routine?
	</p>
	<p>
		This leads to both frustration, and dismissal of functional programming, which is still seen as either academic, or something only interesting in computation-heavy domains like science or finance.
	</p>
	<p>
		It's my secondary goal with these articles to show that:
		<ol>
			<li>There are clear equivalences between known design patterns and concepts from category theory</li>
			<li>Thus, functional programming is as universally useful as OOP</li>
			<li>Since equivalences exist, there's a learning path</li>
		</ol>
		If you're an object-oriented programmer, you can use this catalogue as a learning path. If you'd normally use a <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite</a>, you can look it up and realise that it's the same as a monoid.
	</p>
	<p>
		<strong>Work in progress</strong>
	</p>
	<p>
		I've been thinking about these topics for years. What's a good abstraction? When do abstractions compose?
	</p>
	<p>
		My <a href="http://blog.ploeh.dk/2010/12/03/Towardsbetterabstractions">first attempt at answering these questions</a> was in 2010, but while I had the experience that certain abstractions composed better than others, I lacked the vocabulary. I've been wanting to write a better treatment of the topic ever since, but I've been constantly learning as I've grappled with the concepts.
	</p>
	<p>
		I believe that I now have the vocabulary to take a stab at this again. This is hardly the ultimate treatment. A year from now, I hope to have learned even more, and perhaps that'll lead to further insights or refinement. Still, I can't postpone writing this article until I've stopped learning, because at that time I'll either be dead or senile.
	</p>
	<p>
		I'll write these articles in an authoritative voice, because a text that constantly moderates and qualifies its assertions easily becomes unreadable. Don't consider the tone an indication that I'm certain that I'm right. I've tried to be as rigorous in my arguments as I could, but I don't have a formal education in computer science. I welcome feedback on any article, both if it's to corroborate my findings, or if it's to refute them. If you have any sort of feedback, then <a href="https://github.com/ploeh/ploeh.github.com#readme">please leave a comment</a>.
	</p>
	<p>
		I consider the publication of these articles as though I submit them to peer review. If you can refute them, they deserve to be refuted. If not, they just may be valuable to other people.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Category theory generalises some intuitive relations, such as how numbers combine (e.g. via addition or multiplication). Instead of discussing numbers, however, category theory considers abstract 'objects'. This field of mathematics explore how object relate and compose.
	</p>
	<p>
		Some category theory concepts can be translated to code. These universal abstractions can form the basis of a powerful and concise software design vocabulary.
	</p>
	<p>
		The design patterns movement was an early attempt to create such a vocabulary. I think using category theory offers the chance of a better vocabulary, but fortunately, all the work that went into design patterns isn't wasted. It seems to me that some design patterns are essentially ad-hoc, informally specified, specialised instances of basic category theory concepts. There's quite a bit of overlap. This should further strengthen the argument that category theory is valuable in programming, because some of the concepts are equivalent to design patterns that have already proven useful.
	</p>
	<p>
		<strong>Next:</strong> <a href="http://blog.ploeh.dk/2017/10/05/monoids-semigroups-and-friends">Monoids, semigroups, and friends</a>.
	</p>
</div>

<div id="comments">
	<hr />
	<h2 id="comments-header">Comments</h2>
	<div class="comment" id="4ef6608d77ea49e7b8335562a9a6fa19">
		<div class="comment-author">
			<a href="https://hettomei.github.io/">Tim</a>
		</div>
		<div class="comment-content">
			<p>What a perfect introduction !</p>

			<p>I heard about category theory more than one year ago. But it was from a PhD who code in 'haskell' and I thought it was too hard for me to understand.</p>

			<p>And then, this post.</p>

			<p>Thank you a lot! (you aleardy published the follow up ! yeah)</p>

		</div>
		<div class="comment-date">2017-10-05 21:39 UTC</div>
	</div>
</div>
