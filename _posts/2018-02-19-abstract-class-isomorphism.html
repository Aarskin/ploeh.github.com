---
layout: post
title: "Abstract class isomorphism"
date: 2018-02-19 13:10 UTC
tags: [Software Design, Dependency Injection]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Abstract classes are isomorphic to Dependency Injection.</em>
	</p>
	<p>
		This article is part of <a href="http://blog.ploeh.dk/2018/01/08/software-design-isomorphisms">a series of articles about software design isomorphisms</a>.
	</p>
	<p>
		The introduction to <a href="http://amzn.to/XBYukB">Design Patterns</a> states:
		<blockquote>
			Program to an interface, not an implementation.
		</blockquote>
		When I originally read that, I took it quite literally, so I wrote all my C# code using interfaces instead of abstract classes. There are several reasons why, in general, that turns out to be a good idea, but that's not the point of this article. It turns out that it doesn't really matter.
	</p>
	<p>
		If you have an abstract class, you can refactor to an object model composed from interfaces without loss of information. You can also refactor back to an abstract class. These two refactorings are each others' inverses, so together, they form an isomorphism.
	</p>
	<p>
		<img src="/content/binary/abstract-class-to-interfaces-isomorphism.png" alt="Abstract class on the left, concrete class with injected interfaces on the right; arrow between boxes.">
	</p>
	<p>
		When refactoring an abstract class, you extract all its pure virtual members to an interface, each of its virtual members to other interfaces, and inject them into a concrete class. The inverse refactoring involves going back to an abstract class.
	</p>
	<p>
		This is an important result, because upon closer inspection, the Gang of Four didn't have C# or Java interfaces in mind. The book pre-dates both Java and C#, and its examples are mostly in C++. Many of the examples involve abstract classes, but more than ten years of experience has taught me that I can always write a variant that uses C# interfaces. That is, I believe, not a coincidence.
	</p>
	<p>
		<strong>Abstract class</strong>
	</p>
	<p>
		An abstract class in C# has this general shape:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Class1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Data1</span>&nbsp;Data&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;<span style="color:blue;">set</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:#2b91af;">OutPureVirt1</span>&nbsp;PureVirt1(<span style="color:#2b91af;">InPureVirt1</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:#2b91af;">OutPureVirt2</span>&nbsp;PureVirt2(<span style="color:#2b91af;">InPureVirt2</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:#2b91af;">OutPureVirt3</span>&nbsp;PureVirt3(<span style="color:#2b91af;">InPureVirt3</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;pure&nbsp;virtual&nbsp;members...</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:#2b91af;">OutVirt1</span>&nbsp;Virt1(<span style="color:#2b91af;">InVirt1</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutVirt1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:#2b91af;">OutVirt2</span>&nbsp;Virt2(<span style="color:#2b91af;">InVirt2</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutVirt2&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:#2b91af;">OutVirt3</span>&nbsp;Virt3(<span style="color:#2b91af;">InVirt3</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutVirt3&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;virtual&nbsp;members...</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc1</span>&nbsp;Op1(<span style="color:#2b91af;">InConc1</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc2</span>&nbsp;Op2(<span style="color:#2b91af;">InConc2</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc2&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc3</span>&nbsp;Op3(<span style="color:#2b91af;">InConc3</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc3&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;concrete&nbsp;members...</span>
}</pre>
	</p>
	<p>
		Like in <a href="http://blog.ploeh.dk/2018/02/12/object-isomorphisms">the previous article</a>, I've deliberately kept the naming abstract (but added a more concrete example towards the end). The purpose of this article series is to look at the shape of code, instead of what it does, or why. From <a href="http://blog.ploeh.dk/2018/01/29/argument-list-isomorphisms">argument list isomorphisms</a> we know that we can represent any method as taking a single input value, and returning a single output value.
	</p>
	<p>
		An abstract class can have non-virtual members. In C#, this is the default, whereas in Java, you'd explicitly have to use the <code>final</code> keyword. In the above generalised representation, I've named these non-virtual members <code>Op1</code>, <code>Op2</code>, and so on.
	</p>
	<p>
		An abstract class can also have virtual members. In C#, you must explicitly use the <code>virtual</code> keyword in order to mark a method as overridable, whereas this is the default for Java. In the above representation, I've called these methods <code>Virt1</code>, <code>Virt2</code>, etcetera.
	</p>
	<p>
		Some virtual members are <em>pure virtual</em> members. These are members without an implementation. Any concrete (that is: non-abstract) class inheriting from an abstract class must provide an implementation for such members. In both C# and Java, you must declare such members using the <code>abstract</code> keyword. In the above representation, I've called these methods <code>PureVirt1</code>, <code>PureVirt2</code>, and so on.
	</p>
	<p>
		Finally, an abstract class can contain data, which you can represent as a single data object, here of the type <code>Data1</code>.
	</p>
	<p>
		The concrete and virtual members could, conceivably, call other members in the class - both concrete, virtual, and pure virtual. In fact, this is how many of the design patterns in the book work, for example <a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy</a>, <a href="https://en.wikipedia.org/wiki/Template_method_pattern">Template Method</a>, and <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder</a>.
	</p>
	<p>
		<strong>From abstract class to Dependency Injection</strong>
	</p>
	<p>
		Apart from its <code>Data</code>, an abstract class contains three types of members:
		<ul>
			<li>Those that <em>must</em> be implemented by derived classes: pure virtual members</li>
			<li>Those that <em>optionally</em> can be overriden by derived classes: virtual members</li>
			<li>Those that cannot be overridden by derived classes: concrete, sealed, or final, members</li>
		</ul>
		When refactoring to interfaces, you do the following:
		<ol>
			<li>Extract an interface from the pure virtual members.</li>
			<li>Extract an interface from each of the virtual members.</li>
			<li>Implement each of the 'virtual member interfaces' with the implementation from the virtual member.</li>
			<li>Add a constructor to the abstract class that takes all these new interfaces as arguments. Save the arguments as class fields.</li>
			<li>Change all code in the abstract class to talk to the injected interfaces instead of direct class members.</li>
			<li>Remove the virtual and pure virtual members from the class, or make them non-virtual. If you keep them around, their implementation should be one line of code, delegating to the corresponding interface.</li>
			<li>Change the class to a concrete (non-abstract) class.</li>
		</ol>
		If you apply this refactoring to the above class, you should arrive at something like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Class1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IInterface1</span>&nbsp;pureVirts;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IVirt1</span>&nbsp;virt1;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IVirt2</span>&nbsp;virt2;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IVirt3</span>&nbsp;virt3;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;virt&nbsp;fields...</span>
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Data1</span>&nbsp;Data&nbsp;{&nbsp;<span style="color:blue;">get</span>;&nbsp;<span style="color:blue;">set</span>;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Class1(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IInterface1</span>&nbsp;pureVirts,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IVirt1</span>&nbsp;virt1,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IVirt2</span>&nbsp;virt2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IVirt3</span>&nbsp;virt3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">/*&nbsp;More&nbsp;virt&nbsp;arguments...&nbsp;*/</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.pureVirts&nbsp;=&nbsp;pureVirts;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.virt1&nbsp;=&nbsp;virt1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.virt2&nbsp;=&nbsp;virt2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.virt3&nbsp;=&nbsp;virt3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;field&nbsp;assignments</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc1</span>&nbsp;Op1(<span style="color:#2b91af;">InConc1</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc1&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc2</span>&nbsp;Op2(<span style="color:#2b91af;">InConc2</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc2&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">OutConc3</span>&nbsp;Op3(<span style="color:#2b91af;">InConc3</span>&nbsp;arg)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;Do&nbsp;stuff&nbsp;with&nbsp;this,&nbsp;Data,&nbsp;and&nbsp;arg;&nbsp;return&nbsp;an&nbsp;OutConc3&nbsp;value.</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;concrete&nbsp;members...</span>
}</pre>
	</p>
	<p>
		While not strictly necessary, I've marked the class <code>sealed</code> (<code>final</code> in Java) in order to drive home the point that this is no longer an abstract class.
	</p>
	<p>
		This is an example of the Constructor Injection design pattern. (This is not a Gang of Four pattern; you can find a description in <a href="http://amzn.to/12p90MG">my book about Dependency Injection</a>.)
	</p>
	<p>
		Since it's optional to override virtual members, any class originally inheriting from an abstract class can choose to override only one, or two, of the virtual members, while leaving other virtual members with their default implementations. In order to support such piecemeal redefinition, you can extract each virtual member to a separate interface, like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IVirt1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">OutVirt1</span>&nbsp;Virt1(<span style="color:#2b91af;">InVirt1</span>&nbsp;arg);
}</pre>
	</p>
	<p>
		Notice that each of these 'virtual interfaces' are injected into <code>Class1</code> as a separate argument. This enables you to pass your own implementation of exactly those you wish to change, while you can pass in the default implementation for the rest. The default implementations are the original code from the virtual members, but moved to a class that implements the interfaces:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">DefaultVirt</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IVirt1</span>,&nbsp;<span style="color:#2b91af;">IVirt2</span>,&nbsp;<span style="color:#2b91af;">IVirt3</span>
</pre>
	</p>
	<p>
		When inheriting from the original abstract class, however, you must implement all the pure virtual members, so you can extract a single interface from all the pure virtual members:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IInterface1</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">OutPureVirt1</span>&nbsp;PureVirt1(<span style="color:#2b91af;">InPureVirt1</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">OutPureVirt2</span>&nbsp;PureVirt2(<span style="color:#2b91af;">InPureVirt2</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">OutPureVirt3</span>&nbsp;PureVirt3(<span style="color:#2b91af;">InPureVirt3</span>&nbsp;arg);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;More&nbsp;pure&nbsp;virtual&nbsp;members...</span>
}</pre>
	</p>
	<p>
		This forces anyone who wants to use the refactored (sealed) <code>Class1</code> to provide an implementation of all of those members. There's an edge case where you inherit from the original <code>Class1</code> in order to create a new <em>abstract</em> class, and implement only one or two of the pure virtual members. If you want to support that edge case, you can define an interface for each pure virtual member, instead of one big interface, similar to <code>IVirt1</code>, <code>IVirt2</code>, and so on.
	</p>
	<p>
		<strong>From Dependency Injection to abstract class</strong>
	</p>
	<p>
		I hope it's clear how to perform the inverse refactoring. Assume that the above sealed <code>Class1</code> is the starting point:
		<ol>
			<li>Mark <code>Class1</code> as <code>abstract</code>.</li>
			<li>For each of the members of <code>IInterface1</code>, add a pure virtual member.</li>
			<li>For each of the members of <code>IVirt1</code>, <code>IVirt2</code>, and so on, add a virtual member.</li>
			<li>Move the code from the default implementation of the 'virtual interfaces' to the new virtual members.</li>
			<li>Delete the dependency fields and remove the corresponding arguments from the constructor.</li>
			<li>Clean up orphaned interfaces and implementations.</li>
		</ol>
		This refactoring assumes a class using Dependency Injection like the one shown in this article, above. The example code is the same as the above example code, although the order is reversed: you start with the Dependency Injection class and end with the abstract class.
	</p>
	<p>
		<strong>Example: Gang of Four maze Builder as an abstract class</strong>
	</p>
	<p>
		As an example, consider the original Gang of Four example of the <a href="https://en.wikipedia.org/wiki/Builder_pattern">Builder</a> pattern. The example in the book is based on an abstract class called <code>MazeBuilder</code>. Translated to C#, it looks like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MazeBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildMaze()&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildRoom(<span style="color:blue;">int</span>&nbsp;room)&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildDoor(<span style="color:blue;">int</span>&nbsp;roomFrom,&nbsp;<span style="color:blue;">int</span>&nbsp;roomTo)&nbsp;{&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">abstract</span>&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;GetMaze();
}</pre>
	</p>
	<p>
		In the book, all four methods are virtual, because:
		<blockquote>
			"They're not declared pure virtual to let derived classes override only those methods in which they're interested."
		</blockquote>
		When it comes to the <code>GetMaze</code> method, this means that the method in the book returns a null reference by default. Since this seems like poor API design, and also because the example becomes more illustrative if the class has both abstract and virtual members, I changed it to be abstract (i.e. pure virtual).
	</p>
	<p>
		In general, there are various other issues with this design, the most glaring of which is the implied <a href="http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling">sequence coupling</a> between members: you're expected to call <code>BuildMaze</code> before any of the other methods. A better design would be to remove that explicit step entirely, or else turn it into a factory that you have to call in order to be able to call the other methods. That's not the topic of the present article, so I'll leave the API like this.
	</p>
	<p>
		The book also shows a simple usage example of the abstract <code>MazeBuilder</code> class:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;CreateMaze(<span style="color:#2b91af;">MazeBuilder</span>&nbsp;builder)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildMaze();
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildRoom(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildRoom(2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;builder.BuildDoor(1,&nbsp;2);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;builder.GetMaze();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		You use it with e.g. a <code>StandardMazeBuilder</code> like this:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">StandardMazeBuilder</span>();
 
<span style="color:blue;">var</span>&nbsp;maze&nbsp;=&nbsp;game.CreateMaze(builder);</pre>
	</p>
	<p>
		You could also, again following the book's example as closely as possible, use it with a <code>CountingMazeBuilder</code>, like this:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CountingMazeBuilder</span>();
 
game.CreateMaze(builder);
 
<span style="color:blue;">var</span>&nbsp;msg&nbsp;=&nbsp;<span style="color:#a31515;">$&quot;The&nbsp;maze&nbsp;has&nbsp;</span>{builder.RoomCount}<span style="color:#a31515;">&nbsp;rooms&nbsp;and&nbsp;</span>{builder.DoorCount}<span style="color:#a31515;">&nbsp;doors.&quot;</span>;</pre>
	</p>
	<p>
		This would produce <code>"The maze has 2 rooms and 1 doors."</code>.
	</p>
	<p>
		Both <code>StandardMazeBuilder</code> and <code>CountingMazeBuilder</code> are concrete classes that derive from the abstract <code>MazeBuilder</code> class.
	</p>
	<p>
		<strong>Maze Builder refactored to interfaces</strong>
	</p>
	<p>
		If you follow the refactoring outline in this article, you can refactor the above <code>MazeBuilder</code> class to a set of interfaces. The first should be an interface extracted from all the pure virtual members of the class. In this example, there's only one such member, so the interface becomes this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;GetMaze();
}</pre>
	</p>
	<p>
		The three virtual members each get their own interface, so that you can pick and choose which of them you want to override, and which of them you prefer to keep with their default implementation (which, in this particular case, is to do nothing).
	</p>
	<p>
		The first one was difficult to name:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;BuildMaze();
}</pre>
	</p>
	<p>
		An interface with a single method called <code>BuildMaze</code> would naturally have a name like <code>IMazeBuilder</code>, but unfortunately, I just used that name for the previous interface. The reason I named the above interface <code>IMazeBuilder</code> is because this is an interface extracted from the <code>MazeBuilder</code> abstract class, and I consider the pure virtual API to be the core API of the abstraction, so I think it makes most sense to keep the name for that interface. Thus, I had to come up with a <a href="http://blog.ploeh.dk/2011/05/24/DesignSmellTemporalCoupling">smelly</a> name like <code>IMazeInitializer</code>.
	</p>
	<p>
		Fortunately, the two remaining interfaces are a little better:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;BuildRoom(<span style="color:blue;">int</span>&nbsp;room);
}

<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">interface</span>&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">void</span>&nbsp;BuildDoor(<span style="color:blue;">int</span>&nbsp;roomFrom,&nbsp;<span style="color:blue;">int</span>&nbsp;roomTo);
}</pre>
	</p>
	<p>
		The three virtual members all had default implementations, so you need to keep those around. You can do that by moving the methods' code to a new class that implements the new interfaces:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">DefaultMazeBuilder</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>,&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>,&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>
</pre>
	</p>
	<p>
		In this example, there's no reason to show the implementation of the class, because, as you may recall, all three methods are no-ops.
	</p>
	<p>
		Instead of inheriting from <code>MazeBuilder</code>, implementers now implement the appropriate interfaces:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">StandardMazeBuilder</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>,&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>,&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>,&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>
</pre>
	</p>
	<p>
		This version of <code>StandardMazeBuilder</code> implements all four interfaces, since, before, it overrode all four methods. <code>CountingMazeBuilder</code>, on the other hand, never overrode <code>BuildMaze</code>, so it doesn't have to implement <code>IMazeInitializer</code>:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">CountingMazeBuilder</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>,&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>,&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>
</pre>
	</p>
	<p>
		All of these changes leaves the original <code>MazeBuilder</code> class defined like this:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MazeBuilder</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>,&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>,&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>,&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>&nbsp;mazeBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>&nbsp;mazeInitializer;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>&nbsp;roomBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">private</span>&nbsp;<span style="color:blue;">readonly</span>&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>&nbsp;doorBuilder;
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;MazeBuilder(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>&nbsp;mazeBuilder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>&nbsp;mazeInitializer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>&nbsp;roomBuilder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>&nbsp;doorBuilder)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.mazeBuilder&nbsp;=&nbsp;mazeBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.mazeInitializer&nbsp;=&nbsp;mazeInitializer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.roomBuilder&nbsp;=&nbsp;roomBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.doorBuilder&nbsp;=&nbsp;doorBuilder;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildMaze()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.mazeInitializer.BuildMaze();
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildRoom(<span style="color:blue;">int</span>&nbsp;room)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.roomBuilder.BuildRoom(room);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;BuildDoor(<span style="color:blue;">int</span>&nbsp;roomFrom,&nbsp;<span style="color:blue;">int</span>&nbsp;roomTo)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.doorBuilder.BuildDoor(roomFrom,&nbsp;roomTo);
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;GetMaze()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.mazeBuilder.GetMaze();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>		
	</p>
	<p>
		At this point, you may decide to keep the old <code>MazeBuilder</code> class around, because you may have other code that relies on it. Notice, however, that it's now a concrete class that has dependencies injected into it via its constructor. All four members only delegate to the relevant dependencies in order to do actual work.
	</p>
	<p>
		<code>MazeGame</code> looks like before, but calling <code>CreateMaze</code> looks more complicated:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">StandardMazeBuilder</span>();
 
<span style="color:blue;">var</span>&nbsp;maze&nbsp;=&nbsp;game.CreateMaze(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeBuilder</span>(builder,&nbsp;builder,&nbsp;builder,&nbsp;builder));</pre>
	</p>
	<p>
		Notice that while you're passing four dependencies to the <code>MazeBuilder</code> constructor, you can reuse the same <code>StandardMazeBuilder</code> object for all four roles.
	</p>
	<p>
		If you want to count the rooms and doors, however, <code>CountingMazeBuilder</code> doesn't implement <code>IMazeInitializer</code>, so for that role, you'll need to use the default implementation:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CountingMazeBuilder</span>();
 
game.CreateMaze(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeBuilder</span>(builder,&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DefaultMazeBuilder</span>(),&nbsp;builder,&nbsp;builder));
 
<span style="color:blue;">var</span>&nbsp;msg&nbsp;=&nbsp;<span style="color:#a31515;">$&quot;The&nbsp;maze&nbsp;has&nbsp;</span>{builder.RoomCount}<span style="color:#a31515;">&nbsp;rooms&nbsp;and&nbsp;</span>{builder.DoorCount}<span style="color:#a31515;">&nbsp;doors.&quot;</span>;</pre>
	</p>
	<p>
		If, at this point, you're beginning to wonder what value <code>MazeBuilder</code> adds, then I think that's a legitimate concern. What often happens, then, is that you simply remove that extra layer.
	</p>
	<p>
		<strong>Mazes without MazeBuilder</strong>
	</p>
	<p>
		When you delete the <code>MazeBuilder</code> class, you'll have to adjust <code>MazeGame</code> accordingly:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">Maze</span>&nbsp;CreateMaze(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IMazeInitializer</span>&nbsp;initializer,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IRoomBuilder</span>&nbsp;roomBuilder,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IDoorBuilder</span>&nbsp;doorBuilder,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">IMazeBuilder</span>&nbsp;mazeBuilder)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initializer.BuildMaze();
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomBuilder.BuildRoom(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;roomBuilder.BuildRoom(2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doorBuilder.BuildDoor(1,&nbsp;2);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;mazeBuilder.GetMaze();
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
	</p>
	<p>
		The <code>CreateMaze</code> method now simply takes the four interfaces on which it relies as individual arguments. This simplifies the client code as well:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">StandardMazeBuilder</span>();
 
<span style="color:blue;">var</span>&nbsp;maze&nbsp;=&nbsp;game.CreateMaze(builder,&nbsp;builder,&nbsp;builder,&nbsp;builder);</pre>
	</p>
	<p>
		You can still reuse a single <code>StandardMazeBuilder</code> in all roles, but again, if you only want to count the rooms and doors, you'll have to rely on <code>DefaultMazeBuilder</code> for the behaviour that <code>CountingMazeBuilder</code> doesn't define:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;game&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">MazeGame</span>();
<span style="color:blue;">var</span>&nbsp;builder&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">CountingMazeBuilder</span>();
 
game.CreateMaze(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DefaultMazeBuilder</span>(),&nbsp;builder,&nbsp;builder,&nbsp;builder);
 
<span style="color:blue;">var</span>&nbsp;msg&nbsp;=&nbsp;<span style="color:#a31515;">$&quot;The&nbsp;maze&nbsp;has&nbsp;</span>{builder.RoomCount}<span style="color:#a31515;">&nbsp;rooms&nbsp;and&nbsp;</span>{builder.DoorCount}<span style="color:#a31515;">&nbsp;doors.&quot;</span>;</pre>
	</p>
	<p>
		The order in which dependencies are passed to <code>CreateMaze</code> is different than the order they were passed to the now-deleted <code>MazeBuilder</code> constructor, so you'll have to pass a <code>new DefaultMazeBuilder()</code> as the first argument in order to fill the role of <code>IMazeInitializer</code>. Another way to address this issue is to supply various overloads of the <code>CreateMaze</code> method that uses <code>DefaultMazeBuilder</code> for the behaviour that you don't want to override.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Many of the original design patterns in <em>Design Patterns</em> are described with examples in C++, and many of these examples use abstract classes as the programming interfaces that the Gang of Four really had in mind when they wrote that we should be programming to interfaces instead of implementations.
	</p>
	<p>
		The most important result of this article is that you can reinterpret the original design patterns with C# or Java interfaces and Dependency Injection, instead of using abstract classes. I've done this in C# for more than ten years, and in my experience, you never need abstract classes in a greenfield code base. There's always an equivalent representation that involves composition of interfaces.
	</p>
	<p>
		<strong>Next:</strong> <a href="http://blog.ploeh.dk/2018/02/26/inheritance-composition-isomorphism">Inheritance-composition isomorphism</a>.
	</p>
</div>
<div id="comments">
	<hr />
	<h2 id="comments-header">Comments</h2>
	<div class="comment" id="b8cb5baf6ccd4cc98412c229d3dadb06">
		<div class="comment-author">
			<a href="https://github.com/MaxKot">Max Kiselev</a>
		</div>
		<div class="comment-content">
			<p>
				While the idea is vey interesting I think it is not exactly an isomorphism.
			</p>
			<p>
				The first reason I think it is not an isomorphism is language-specific since Java and C#
				allow implementing multiple interfaces but not multiple abstract classes. It can make a
				reverse transformation from interfaces back to an abstract class non-trivial.
			</p>
			<p>
				The second reason is that abstract class guarantees that whatever class implements the pure
				virtual members and overrides virtual members share the same state between all its methods
				and also with the abstract base class. With the maze Builder example there must be a state
				shared between GetMaze, BuildMaze, BuildRoom and BuildDoor methods but the dependency
				injection does not seem to reflect it.
			</p>
			<p>
				Perhaps there should be some kind of Data parameter passed to all injected interfaces.
			</p>
		</div>
		<div class="comment-date">2018-03-05 19:03 UTC</div>
	</div>

	<div class="comment" id="13cc2c9a28114b52add8942d3ac3c94d">
		<div class="comment-author"><a href="http://blog.ploeh.dk">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Max, thank you for writing, and particularly for applying critique to this post. One of my main motivations for writing <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">the entire article series</a> is that I need to subject my thoughts to peer review. I've been thinking about these things for years, but in order to formalise them, I need to understand whether I'm completely wrong (I hope not), of, if I'm not, what are the limits of my findings.
			</p>
			<p>
				I think you've just pointed at one such limit, and for that I'm grateful. The rest of this answer, then, is not an attempt to refute your comment, but rather an effort to identify some <em>constraints</em> within which what I wrote may still hold.
			</p>
			<p>
				Your second objection doesn't worry me that much, because you also suggest a way around it. I admit that I faked the Maze Builder code somewhat, so that the state isn't explicit. I feel that fudging the code example is acceptable, as the Gang of Four code example is also clearly incomplete. In any case, you're right that an abstract class could easily contain some shared state. When refactoring to interfaces, the orchestrating class could instead pass around that state as an argument to all methods, as you suggest. Would it be reasonable to conclude that this, then, doesn't prevent the translations from being isomorphic?
			</p>
			<p>
				There's still your first objection, which I think is significant. That's the reason I decided to cover your second objection first, because I think it'll require more work to address the first objection.
			</p>
			<p>
				First, I think we need to delimit the problem, since your comment slightly misrepresents my article. The claim in the article is that you can refactor an abstract class to a concrete class with injected dependencies. Furthermore, the article claims that this translation is isomorphic; i.e. that you can refactor a concrete class with injected dependencies to an abstract class.
			</p>
			<p>
				If I read your comment right, you're saying that a class can implement more than one interface, like this:
			</p>
			<p>
				<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MyClass</span>&nbsp;:&nbsp;<span style="color:#2b91af;">IFoo</span>,&nbsp;<span style="color:#2b91af;">IBar</span><br/></pre>
			</p>
			<p>
				I agree that you can't use the transformations described in this article to refactor <code>MyClass</code> to an abstract class, because that's not the transformation that the article describes.
			</p>
			<p>
				That doesn't change that your comment is uncomfortably close to an inconvenient limitation.	You're right that there seems to be a limitation when it comes to C#'s and Java's lack of multiple inheritance. As your comment implies, if a translation is isomorphic, one has to be able to start at either end, and round-trip to the other end and back. Thus, one has to be able to start with a concrete class with injected dependencies, and refactor to an abstract class; for example:
			</p>
			<p>
				<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MyClass</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;MyClass(<span style="color:#2b91af;">IFoo</span>&nbsp;foo,&nbsp;<span style="color:#2b91af;">IBar</span>&nbsp;bar)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>				
			</p>
			<p>
				As far as I can tell, that's exactly the shape of the <code>sealed</code> version of <code>Class1</code>, above, so I'm not convinced that that's a problem, but something like the following does look like a problem to me:
			</p>
			<p>
				<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">MyClass</span><br/>{<br/>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;MyClass(<span style="color:#2b91af;">IFoo</span>&nbsp;foo1,&nbsp;<span style="color:#2b91af;">IFoo</span>&nbsp;foo2)<br/>&nbsp;&nbsp;&nbsp;&nbsp;{<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;...</span><br/>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>}</pre>
			</p>
			<p>
				It's not clear to me how one can refactor something like that to an abstract class, and still retain the distinction between <code>foo1</code> and <code>foo2</code>. My claim is not that this is impossible, but only that it's not immediately clear to me how to do that. Thus, we may have to put a constraint on the original claim, and instead say something like this:
				<blockquote>
					An abstract class is isomorphic to a concrete class with injected dependencies, given that all the injected dependencies are of different types.
				</blockquote>
				We can attempt to illustrate the claim like this:
			</p>
			<p>
				<img src="/content/binary/abstract-class-to-constrained-dependency-injection-isomorphism.png" alt="The set of abstract classes juxtaposed with the set of dependency injection, the latter with a subset for which arrows go both ways between the subset and the set of abstract classes.">
			</p>
			<p>
				This is still an isomorphism, I think, although I invite further criticism of that claim. <a href="http://amzn.to/13tGJ0f">Conceptual Mathematics</a> defines an isomorphism in terms of categories <em>A</em> and <em>B</em>, and as far as I can tell, <em>A</em> and <em>B</em> can be as specific as we want them to be. Thus, we can say that <em>A</em> is the set of abstract classes, and <em>B</em> is the subset of concrete classes with injected dependencies, for which no dependency share the same type.
			</p>
			<p>
				If we have to constrain the isomorphism in this way, though, is it still interesting? Why should we care?
			</p>
			<p>
				To be perfectly honest, what motivated me to write this particular article is that I wanted to describe the translation from an abstract class to dependency injection. The inverse interests me less, but I thought that if the inverse translation exists, I could fit this article in with the other articles in this article series about software design isomorphisms.
			</p>
			<p>
				The reason I care about the translation from abstract class to dependency injection is that I often see code where the programmers misuse inheritance. My experience with C# is that one can completely avoid inheritance. The way to do that is to use dependency injection instead. This article shows how to do that.
			</p>
			<p>
				The result that one can write real, complex code bases in C# without inheritance is important to me, because one of my current goals is to teach people the advantages of functional programming, and one barrier I run into is that people who come from object-oriented programming run into problems when they no longer can use inheritance. Thus, this article shows an object-oriented alternative to inheritance, so that people can get used to the idea of designing without inheritance, even before they start looking at functional programming.
			</p>
			<p>
				Another motivation for this article is that it's part of <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">a much larger article series</a> about design patterns, and how they relate to fundamental abstractions. In <em>Design Patterns</em>, all the (C++) patterns are described in terms of inheritance, so I wrote this article series on isomorphisms in order to be able to represent various design patterns in other forms than they appear in the book.
			</p>
		</div>
		<div class="comment-date">2018-03-08 9:57 UTC</div>
	</div>
</div>
