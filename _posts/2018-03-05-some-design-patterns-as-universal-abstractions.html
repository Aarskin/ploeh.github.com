---
layout: post
title: "Some design patterns as universal abstractions"
date: 2018-03-05 8:10 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>Some design patterns can be formalised by fundamental abstractions.</em>
	</p>
	<p>
		Wouldn't it be wonderful if you could assemble software from predefined building blocks? This idea is <em>old</em>, and has been the driving force behind object-oriented programming (OOP). In <a href="https://www.coupland.com">Douglas Coupland</a>'s 1995 novel <a href="http://bit.ly/microserfs">Microserfs</a>, the characters attempt to reach that goal through a project called <em>Oop!</em>. <a href="https://en.wikipedia.org/wiki/Lego">Lego bricks</a> play a role as a metaphor as well.
	</p>
	<p>		
		<img src="/content/binary/lego-bricks-as-connections.png" alt="Lego bricks.">
	</p>
	<p>
		Decades later, it doesn't look like we're much nearer that goal than before, but I believe that we'd made at least two (rectifiable) mistakes along the way:
		<ul>
			<li>Granularity</li>
			<li>Object-orientation</li>
		</ul>
		While I'm going to discuss both of these briefly, my principal message is one of hope. I still think we can assemble software from predefined 'things', but I believe that these 'things' are small and 'objects' in a different sense than normal.
	</p>
	<p>
		<strong>Granularity</strong>
	</p>
	<p>
		Over the years, I've seen several attempts at reducing software development to a matter of putting things together. These attempts have invariably failed.
	</p>
	<p>
		I believe that one of the reasons for failure is that such projects tend to aim at coarse-grained building blocks. As I explain in the <em>Interface Segregation Principle</em> module of my <a href="{{ site.production_url }}/encapsulation-and-solid">Encapsulation and SOLID</a> Pluralsight course, granularity is a crucial determinant for your ability to create. The coarser-grained the building blocks, the harder it is to create something useful.
	</p>
	<p>
		Most attempts at software-as-building-blocks have used big, specialised building blocks aimed at non-technical users (<em>"Look! Create an entire web site without writing a single line of code!"</em>). That's just like <a href="https://en.wikipedia.org/wiki/Lego_Duplo">Duplo</a>. You can create exactly what the blocks were designed for, but as soon as you try to create something new and original, you can't.
	</p>
	<p>
		<strong>Object-orientation</strong>
	</p>
	<p>
		OOP is another attempt at software-as-building-blocks. In .NET (the OOP framework with which I'm most familiar) the Base Class Library (BCL) is enormous. Many of the reusable objects in the BCL are fine-grained, so at least it's often possible to put them together to create something useful. The problem with an object-oriented library like the .NET BCL, however, is that all the objects are <em>special</em>.
	</p>
	<p>
		The vision was always that software 'components' would be able to 'click' together, just like Lego bricks. The BCL isn't like that. Typically, objects have nothing in common apart from the useless <code>System.Object</code> base class. There's no system. In order to learn how the BCL works, you have to learn the ins and outs of every single class.
	</p>
	<p>
		Better know a framework.
	</p>
	<p>
		It doesn't help that OOP was never formally defined. Every time you see or hear a discussion about what 'real' object-orientation is, you can be sure that sooner or later, someone will say: "...but that's not what <a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> had in mind."
	</p>
	<p>
		What Alan Kay had in mind is still unclear to me, but it seems safe to say that it wasn't what we have now (C++, Java, C#).
	</p>
	<p>
		<strong>Building blocks from category theory</strong>
	</p>
	<p>
		While we (me included) have been on an a thirty-odd year long detour around object-orientation, I don't think all is lost. I still believe that a Lego-brick-like system exists for software development, but I think that it's a system that we have to <em>discover</em> instead of invent.
	</p>
	<p>
		As I already covered in the <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">introductory article</a>, <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a> does, in fact, discuss 'objects'. It's not the same type of object that you know from C# or Java, but some of them do consist of data and behaviour - <a href="http://blog.ploeh.dk/2017/10/06/monoids">monoids</a>, for example, or <a href="http://blog.ploeh.dk/2018/03/22/functors">functors</a>. Such object are more like types than objects in the OOP sense.
	</p>
	<p>
		Another, more crucial, difference to object-oriented programming is that these objects are lawful. An object is only a monoid if it obeys the monoid laws. An object is only a functor if it obeys the functor laws.
	</p>
	<p>
		Such objects are still fine-grained building blocks, but they fit into a system. You don't have to learn tens of thousands of specific objects in order to get to know a framework. You need to understand the system. You need to understand monoids, functors, applicatives, and a few other universal abstractions (yes: monads too).
	</p>
	<p>
		Many of these universal abstractions were almost discovered by the Gang of Four twenty years ago, but they weren't quite in place then. Much of that has to do with the fact that functional programming didn't seem like a realistic alternative back then, because of hardware limitations. This has all changed to the better.
	</p>
	<p>
		<strong>Specific patterns</strong>
	</p>
	<p>
		In the <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">introductory article about the relationship between design patterns and category theory</a>, you learned that some design patterns significantly overlap concepts from category theory. In this article series, we'll explore the relationships between some of the classic patterns and category theory. I'm not sure that all the patterns from <a href="http://amzn.to/XBYukB">Design Patterns</a> can be reinterpreted as universal abstractions, but the following subset seems promising:
		<ul>
			<li><a href="http://blog.ploeh.dk/2018/03/12/composite-as-a-monoid">Composite as a monoid</a>
				<ul>
					<li><a href="http://blog.ploeh.dk/2018/04/09/coalescing-composite-as-a-monoid">Coalescing Composite as a monoid</a></li>
					<li>Endomorphic Composite as a monoid</li>
				</ul>
			</li>
			<li>Null Object as identity</li>
			<li>Visitor</li>
		</ul>
		Granted, Null Object is actually not from <em>Design Patterns</em>, but as we shall see, it's a special case of Composite, so it fits well into that group.
	</p>
	<p>
		<strong>Summary</strong>
	</p>
	<p>
		Some design patterns closely resemble categorical objects. This article provides an overview, whereas the next articles in the series will dive into specifics.
	</p>
	<p>
		<strong>Next:</strong> <a href="http://blog.ploeh.dk/2018/03/12/composite-as-a-monoid">Composite as a monoid</a>.
	</p>
</div>