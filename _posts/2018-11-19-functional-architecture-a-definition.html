---
layout: post
title: "Functional architecture: a definition"
description: "How do you know whether your software architecture follows good functional programming practices? Here's a way to tell."
date: 2018-11-19 9:44 UTC
tags: [Software Design, Architecture, Functional Programming]
image: "/content/binary/impure-actions-pure-functions-all-valid-arrows.png"
image_alt: "Sets of impure activities and pure functions, with arrows going in all directions except from pure to impure."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		Over the years, I've written articles on functional architecture, including <a href="http://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters">Functional architecture is Ports and Adapters</a>, given <a href="https://vimeo.com/180287057">conference talks</a>, and even produced <a href="{{ site.production_url }}/functional-architecture-with-fsharp">a Pluralsight course</a> on the topic. How should we define <em>functional architecture</em>, though?
	</p>
	<p>
		People sometimes ask me about their <a href="https://fsharp.org">F#</a> code: <em>How do I know that my F# code is functional?</em>
	</p>
	<p>
		Please permit me a little detour before I answer that question.
	</p>
	<h3 id="f752f048f6ef445d8625f1710317620b">
		What's the definition of object-oriented design? <a href="#f752f048f6ef445d8625f1710317620b" title="permalink">#</a>
	</h3>
	<p>
		Object-oriented design (OOD) has been around for decades; at least since the nineteen-sixties. Sometimes people get into discussions about whether or not a particular design is good object-oriented design. I know, since I've found myself in such discussions more than once.
	</p>
	<p>
		These discussions usually die out without resolution, because it seems that no-one can provide a sufficiently rigorous definition of OOD that enables people to determine an outcome. One thing's certain, though, so I'd like to posit this corollary to <a href="https://en.wikipedia.org/wiki/Godwin%27s_law">Godwin's law</a>:
		<blockquote>
			As a discussion about OOD grows longer, the probability of a comparison involving Alan Kay approaches 1.
		</blockquote>
		Not that I, in any way, wish to suggest any logical relationship between <a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> and Hitler, but in a discussion about OOD, sooner or later someone states:
		<blockquote>
			"That's not what Alan Kay had in mind!"
		</blockquote>
		That may be true, even.
	</p>
	<p>
		My problem with that assertion is that I've never been able to figure out exactly what Alan Kay had in mind. It's something that involves message-passing and <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>, and conceivably, the best modern example of this style of programming might be <a href="https://www.erlang.org">Erlang</a> (often, ironically, touted as a functional programming language).
	</p>
	<p>
		This doesn't seem to be a good basis for determining whether or not something is object-oriented.
	</p>
	<p>
		In any case, despite what Alan Kay had in mind, that wasn't the object-oriented programming we got. While <a href="https://en.wikipedia.org/wiki/Eiffel_(programming_language)">Eiffel</a> is in many ways a strange programming language, the philosophy of OOD presented in <a href="http://amzn.to/1claOin">Object-Oriented Software Construction</a> feels, to me, like something from which <a href="https://www.java.com">Java</a> could develop.
	</p>
	<p>
		I'm not aware of the detailed history of Java, but the spirit of the language seems more compatible with Bertrand Meyer's vision than with Alan Kay's.
	</p>
	<p>
		Subsequently, C# would hardly look the way it does had it not been for Java.
	</p>
	<p>
		The OOD we got wasn't the OOD originally envisioned. To make matters worse, the OOD we did get seems to be driven by unclear principles. Yes, there's the idea about encapsulation, but while Meyer had some very specific ideas about design-by-contract, that was the distinguishing trait of his vision that <em>didn't</em> make the transition to Java or C#.
	</p>
	<p>
		It's not clear what OOD is, but I think we can do better when it comes to functional programming (FP).
	</p>
	<h3 id="305ccccf2de84354bdb68b5b80d34fc9">
		Referential transparency <a href="#305ccccf2de84354bdb68b5b80d34fc9" title="permalink">#</a>
	</h3>
	<p>
		It's possible to pinpoint what FP is to a degree not possible with OOD. Some people may be uncomfortable with the following definition; I don't claim that this is a generally accepted definition. It does have, however, the advantage that it's precise and supports <a href="https://en.wikipedia.org/wiki/Falsifiability">falsification</a>.
	</p>
	<p>
		The foundation of FP is <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>. It's the idea that, for an expression, the left- and right-hand sides of the equal sign are truly equal:
	</p>
	<p>
		<pre>two = 1 + 1</pre>
	</p>
	<p>
		In <a href="https://www.haskell.org">Haskell</a>, this is enforced by the compiler. The <code>=</code> operator truly implies equality. To be clear, this isn't the case in C#:
	</p>
	<p>
		<pre><span style="color:blue;">var</span>&nbsp;two&nbsp;=&nbsp;1&nbsp;+&nbsp;1;</pre>
	</p>
	<p>
		In C#, Java, and other imperative languages, the <code>=</code> implies <em>assignment</em>, not equality. Here, <code>two</code> can change, despite the absurdity of the claim.
	</p>
	<p>
		When code is referentially transparent, then you can substitute the expression on the right-hand side with the symbol on the left-hand side. This seems obvious when we consider addition of two numbers, but becomes less clear when we consider function invocation:
	</p>
	<p>
		<pre>i = findBestNumber [42, 1337, 2112, 90125]</pre>
	</p>
	<p>
		In Haskell, functions are referentially transparent. You don't know exactly what <code>findBestNumber</code> does, but you do know that you can substitute <code>i</code> with <code>findBestNumber [42, 1337, 2112, 90125]</code>, or vice versa.
	</p>
	<p>
		In order for a function to be referentially transparent (also known as a <a href="https://en.wikipedia.org/wiki/Pure_function">pure function</a>), it must have two properties:
		<ul>
			<li>It must always return the same output for the same input. We call this quality <em>determinism</em>.</li>
			<li>It must have no side effects.</li>
		</ul>
		As far as I can tell, all else in FP follows from this definition. For example, values must be immutable, because if they aren't, you could mutate them, and that would count as a side effect.
	</p>
	<p>
		The reason I prefer this definition is that it supports falsification. You can assert that a function or value is pure; all it takes is a single counter-example to prove that it's not. A counter-example can be either an input value that doesn't always produce the same return value, or a function call that produces a side effect.
	</p>
	<p>
		I'm not aware of any other definition that offers similar decision power.
	</p>
	<h3 id="43505c00cc25416db2b47a89912fd731">
		IO <a href="#43505c00cc25416db2b47a89912fd731" title="permalink">#</a>
	</h3>
	<p>
		All software produces side effects: Changing a pixel on a monitor is a side effect. Writing a byte to disk is a side effect. Transmitting a bit over a network is a side effect. It seems that it'd be impossible to interact with pure functions, and indeed, it is, without some sort of affordance for impurity.
	</p>
	<p>
		Haskell resolves this problem with the <code>IO</code> monad, but the purpose of this article isn't to serve as an introduction to Haskell, monads, or <code>IO</code>. The point is only that in FP, you need some sort of 'wormhole' that will enable you to interact with the real world. There's no way around that, but logically, the rules still apply. Pure functions must stay deterministic and free of side effects.
	</p>
	<p>
		It follows that you have two groups of operations: impure activities and pure functions.
	</p>
	<p>
		<img src="/content/binary/impure-actions-pure-functions-no-arrows.png" alt="Two sets: the set of impure activities and the set of pure functions.">
	</p>
	<p>
		While there are rules for pure functions, those rules still allow for interaction. One pure function can call another pure function. Such an interaction doesn't change the properties of any of those functions. Both caller and callee remain side-effect-free and deterministic.
	</p>
	<p>
		<img src="/content/binary/impure-actions-pure-functions-pure-arrows.png" alt="Set of impure activities and set of pure functions. The pure functions now have arrows between them.">
	</p>
	<p>
		The impure activities can also interact. No rules apply to them:
	</p>
	<p>
		<img src="/content/binary/impure-actions-pure-functions-impure-and-pure-arrows.png" alt="Sets of impure activities and pure functions. Both sets now have internal arrows.">
	</p>
	<p>
		Finally, since no rules apply to impure activities, they can invoke pure functions:
	</p>
	<p>
		<img src="/content/binary/impure-actions-pure-functions-all-valid-arrows.png" alt="Sets of impure activities and pure functions, now also with arrows going from impure to pure.">
	</p>
	<p>
		Impure activities are unbound by rules, so they can do anything they need to do, including painting pixels, writing to files, or calling pure functions. A pure function is deterministic and has no side effects. Those properties don't change just because the result is subsequently displayed on a screen.
	</p>
	<p>
		The fourth combination of arrows is, however, illegal.
		<blockquote>
			A pure function can't invoke an impure activity.
		</blockquote>
		If it did, it would either transitively produce a side effect or non-deterministic behaviour.
	</p>
	<p>
		This is the rule of functional architecture. You can also explain it with a table:
		<table>
			<col>
			<col>
			<colgroup span="2"></colgroup>
			<thead>
				<tr>
					<td colspan="2" rowspan="2"></td>
					<th colspan="2" scope="colgroup">Callee</th>
				</tr>
				<tr>
					<th scope="col">Impure</th>
					<th scope="col">Pure</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th rowspan="2" scope="rowgroup">Caller</th>
					<th scope="row">Impure</th>
					<td><span style="color:green">Valid</span></td>
					<td><span style="color:green">Valid</span></td>
				</tr>
				<tr>
					<th scope="row">Pure</th>
					<td><span style="color:red">Invalid</span></td>
					<td><span style="color:green">Valid</span></td>
				</tr>
			</tbody>
		</table>
		Let's call the above rule the <em>functional interaction law</em>: a pure function can't invoke an impure activity. A functional architecture, then, is a code base that obeys that law, and has a significant portion of pure code.
	</p>
	<p>
		Clearly, you can trivially obey the functional interaction law by writing exclusively impure code. In a sense, this is what you do by default in imperative programming languages. If you're familiar with Haskell, imagine writing an entire program in <code>IO</code>. That would be possible, but pointless.
	</p>
	<p>
		Thus, we need to add the qualifier that a significant part of the code base should consist of pure code. How much? The more, the better. Subjectively, I'd say significantly more than half the code base should be pure. I'm concerned, though, that stating a hard limit is as useful here <a href="http://blog.ploeh.dk/2015/11/16/code-coverage-is-a-useless-target-measure">as it is for code coverage</a>.
	</p>
	<h3 id="1009a90ea922424285e5f9a4bb30524e">
		Tooling <a href="#1009a90ea922424285e5f9a4bb30524e" title="permalink">#</a>
	</h3>
	<p>
		How do you verify that you obey the functional interaction law? Unfortunately, in most languages the answer is that this requires painstaking analysis. This can be surprisingly tricky to get right. Consider this realistic F# example:
	</p>
	<p>
		<pre><span style="color:blue;">let</span>&nbsp;createEmailNotification&nbsp;templates&nbsp;msg&nbsp;(user&nbsp;:&nbsp;UserEmailData)&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;{&nbsp;SubjectLine&nbsp;=&nbsp;subjectTemplate;&nbsp;Content&nbsp;=&nbsp;contentTemplate&nbsp;}&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;templates
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Map.tryFind&nbsp;user.Localization
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&gt;&nbsp;Option.defaultValue&nbsp;(Map.find&nbsp;Localizations.english&nbsp;templates)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;r&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Templating.append
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Templating.replacementOfEnvelope&nbsp;msg)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Templating.replacementOfFlatRecord&nbsp;user)
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;subject&nbsp;=&nbsp;Templating.run&nbsp;subjectTemplate&nbsp;r
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;content&nbsp;=&nbsp;Templating.run&nbsp;contentTemplate&nbsp;r
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecipientUserId&nbsp;=&nbsp;user.UserId
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EmailAddress&nbsp;=&nbsp;user.EmailAddress
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotificationSubjectLine&nbsp;=&nbsp;subject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotificationText&nbsp;=&nbsp;content
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreatedDate&nbsp;=&nbsp;DateTime.UtcNow
&nbsp;&nbsp;&nbsp;&nbsp;}</pre>
	</p>
	<p>
		Is this a pure function?
	</p>
	<p>
		You may protest that this isn't a fair question, because you don't know what, say, <code>Templating.replacementOfFlatRecord</code> does, but that turns out to be irrelevant. The presence of <code>DateTime.UtcNow</code> makes the entire function impure, because getting the current date and time is non-deterministic. This trait is transitive, which means that any code that calls <code>createEmailNotification</code> is also going to be impure.
	</p>
	<p>
		That means that the purity of an expression like the following easily becomes obscure.
	</p>
	<p>
		<pre><span style="color:blue;">let</span>&nbsp;emailMessages&nbsp;=&nbsp;specificUsers&nbsp;|&gt;&nbsp;Seq.map&nbsp;(createEmailNotification&nbsp;templates&nbsp;msg)</pre>
	</p>
	<p>
		Is this a pure expression? In this case, we've just established that <code>createEmailNotification</code> is impure, so that wasn't hard to answer. The problem, however, is that the burden is on you, the code reader, to remember which functions are pure, and which ones aren't. In a large code base, this soon becomes a formidable endeavour.
	</p>
	<p>
		It'd be nice if there was a tool that could automatically check the functional interaction law.
	</p>
	<p>
		This is where many people in the functional programming community become uncomfortable about this definition of functional architecture. The only tools that I'm aware of that enforce the functional interaction law are a few programming languages, most notably Haskell (others exist, too).
	</p>
	<p>
		Haskell enforces the functional interaction law via its <code>IO</code> type. You can't use an <code>IO</code> value from within a pure function (a function that doesn't return <code>IO</code>). If you try, your code doesn't compile.
	</p>
	<p>
		I've personally used Haskell repeatedly to understand the limits of functional architecture, for example to establish that <a href="http://blog.ploeh.dk/2017/01/30/partial-application-is-dependency-injection">Dependency Injection isn't functional</a> because it makes everything impure.
	</p>
	<p>
		The overall lack of tooling, however, may make people uncomfortable, because it means that most so-called functional languages (e.g. F#, Erlang, <a href="https://elixir-lang.org/">Elixir</a>, and <a href="https://clojure.org">Clojure</a>) offer no support for validating or enforcing functional architecture.
	</p>
	<p>
		My own experience with writing entire applications in F# is that I frequently, inadvertently violate the functional interaction law somewhere deep in the bowels of my code.
	</p>
	<h3 id="8e33b2ffd51f46f18e38c5add37f1728">
		Conclusion <a href="#8e33b2ffd51f46f18e38c5add37f1728" title="permalink">#</a>
	</h3>
	<p>
		What's functional architecture? I propose that it's code that obeys the functional architecture law, and that is made up of a significant portion of pure functions.
	</p>
	<p>
		This is a narrow definition. It excludes a lot of code bases that could easily be considered 'functional enough'. By the definition, I don't intend to denigrate fine programming languages like F#, Clojure, Erlang, etcetera. I personally find it a joy to write in F#, which is my default language choice for .NET programming.
	</p>
	<p>
		My motivation for offering this definition, albeit restrictive, is to avoid the OOD situation where it seems entirely subjective whether or not something is object-oriented. With the functional interaction law, we may conclude that most (non-Haskell) programs are probably not 'really' functional, but at least we establish an falsifiable ideal to strive for.
	</p>
	<p>
		This would enable us to look at, say, an F# code base and start discussing <em>how close to the ideal is it?</em>
	</p>
	<p>
		Ultimately, functional architecture isn't a goal in itself. It's a means to achieve an objective, such as a sustainable code base. I find that FP helps me keep a code base sustainable, but often, 'functional enough' is sufficient to accomplish that.
	</p>
</div>