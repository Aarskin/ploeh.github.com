---
layout: post
title: "A reading of Extensibility for the Masses"
description: "A paper read and translated to C#."
date: 2021-07-12 5:36 UTC
tags: [Software Design, Design Patterns]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		When I have the time (and I do make this a priority) I set aside an hour every day to study. Lately I've been using these time slots to read and reproduce the code in the 2012 paper <em>"Extensibility for the Masses. Practical Extensibility with Object Algebras"</em> by Bruno C. d. S. Oliveira and William R. Cook. As is often common with academic papers, they don't have a single, authoritative address on the internet. You can find the paper in various places. I've used <a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">a copy hosted by University of Texas</a>, which is the institution with which William R. Cook is associated.
	</p>
	<p>
		While the example code in the paper is in Java, the authors claim that it translates easily to C#. I decided to give this a try, and found it to be true.
	</p>
	<h3 id="673345bb9c48466790a40e4c5e239240">
		Git repository <a href="#673345bb9c48466790a40e4c5e239240" title="permalink">#</a>
	</h3>
	<p>
		From the beginning I created <a href="https://github.com/ploeh/ExtensibilityForMasses">a Git repository</a> with an eye to publishing it in case anyone was interested in looking over my shoulder. Not only can you see the 'final' translation, but you can also follow along with each commit.
	</p>
	<p>
		I committed each time I had something that seemed to work. When I struggled to understand how to interpret some of the code, I left detailed commit messages describing my doubts, and explaining why I had chosen to interpret things in a particular way.
	</p>
	<p>
		Along the way I also added automated tests, because I found that the paper lacked examples. Those tests represent my own interpretation of the code in the paper, and how one is supposed to use it. In total, I wrote 75 test cases.
	</p>
	<h3 id="05a8b46089be4fed9ead17648df68bef">
		Help from one of the authors <a href="#05a8b46089be4fed9ead17648df68bef" title="permalink">#</a>
	</h3>
	<p>
		At one time I hit a snag that I couldn't readily resolve. After searching the web in vain, I posted <a href="https://stackoverflow.com/q/67818254/126014">a question on Stack Overflow</a>. After a few days, I got an answer from Bruno C. d. S. Oliveira, one of the authors of the paper!
	</p>
	<p>
		It turns out that some of my confusion stemmed from an otherwise inconsequential error in the paper. We shouldn't be shocked that an academic paper contains errors. One of many things I learned from reading Charles Petzold's excellent book <a href="http://amzn.to/2n9MFGh">The Annotated Turing</a> was that later researchers found several errors in Turing's 1936 paper, but none that changed the overall conclusion. So it seems to be here as well. There's at least one confirmed error (and another one that I only suspect), but it's inconsequential and easily corrected.
	</p>
	<p>
		It does, however, raise a point about scientific papers in general: Even if they're peer-reviewed they may contain errors. I'm <a href="/2020/05/25/wheres-the-science">much in favour of scientific knowledge, but also sceptical about some claims about computer science and software engineering</a>.
	</p>
	<h3 id="1cd1086ddbe84c83910dddad451efdbc">
		Readability <a href="#1cd1086ddbe84c83910dddad451efdbc" title="permalink">#</a>
	</h3>
	<p>
		The paper's title claims to give extensibility to the masses, but will 'the masses' be able to read the paper? As papers go, I found this one quite readable. While other papers present their examples in <a href="https://www.haskell.org">Haskell</a>, this one uses Java. If you're comfortable with Java (or C#), you should be able to follow the code examples (or my C# translation).
	</p>
	<p>
		You won't entirely escape Greek letters or other <a href="/2021/06/07/abstruse-nomenclature">abstruse nomenclature</a>. This is, after all, an academic paper, so it can't be lucid all the way through. There's a section called <em>Algebraic Signatures, F-Algebras, and Church Encodings</em> that is definitely not for 'the masses'. I understand enough about <a href="https://bartoszmilewski.com/2017/02/28/f-algebras/">F-algebras</a> and <a href="/2018/05/22/church-encoding">Church encodings</a> to follow the outline of this section, but I didn't find it helpful.
	</p>
	<p>
		If you're interested in the overall article, but don't know what these words mean, I suggest you skim those parts and pay as much attention to the details as when <a href="https://en.wikipedia.org/wiki/Geordi_La_Forge">Geordi La Forge</a> spews <a href="https://en.wikipedia.org/wiki/Technobabble">technobabble</a>. In other words, I think you can follow the rest of the article just was well, even if <em>Church<sub>Σ</sub> = ∀A.(T<sub>1</sub> → A) × ... × (T<sub>n</sub> → A) → A</em> makes no sense to you.
	</p>
	<h3 id="c42c389e557a47848d4c66af477297ca">
		Conclusion <a href="#c42c389e557a47848d4c66af477297ca" title="permalink">#</a>
	</h3>
	<p>
		Does the paper deliver on its promise? Yes and no. Formally, I think that it does. In the beginning, it establishes some criteria for a successful solution, and as far as I can tell, it can check off all of them.
	</p>
	<p>
		It's also true that the proposed solution requires only intermediary language features. Generics and inheritance, as they're available in C# and Java, is all that's required.
	</p>
	<p>
		On the other hand, I don't find the paper's examples compelling. Few 'mass developers' are tasked with implementing a simple expression-based language. I can't shake the feeling that most of what the paper accomplishes could be handled with tasty application of composition and the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapter pattern</a>.
	</p>
	<p>
		Still, I'll keep this paper in mind if I ever have to publish a reusable and extensible, type-safe software library.
	</p>
</div>