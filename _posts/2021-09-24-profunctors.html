---
layout: post
title: "Profunctors"
description: "A functor that's both co- and contravariant. An article for C# programmers."
date: 2021-09-24 14:26 UTC
tags: [Software Design]
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		This article series is part of <a href="/2018/03/19/functors-applicatives-and-friends">a larger series of articles about functors, applicatives, and other mappable containers</a>. Particularly, you've seen examples of both <a href="/2018/03/22/functors">functors</a> and <a href="/2021/09/02/contravariant-functors">contravariant functors</a>.
	</p>
	<p>
		What happens if you, so to speak, combine those two?
	</p>
	<h3 id="20df8ada70644ca2a4a5363f05f89216">
		Mapping in both directions <a href="#20df8ada70644ca2a4a5363f05f89216" title="permalink">#</a>
	</h3>
	<p>
		A <em>profunctor</em> is like a <a href="/2018/12/24/bifunctors">bifunctor</a>, except that it's contravariant in one of its arguments (and covariant in the other). Usually, you'd list the contravariant argument first, and the covariant argument second. By that convention, a hypothetical <code>Profunctor&lt;A, B&gt;</code> would be contravariant in <code>A</code> and covariant in <code>B</code>.
	</p>
	<p>
		In order to support such mapping, you could give the class a <code>DiMap</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">sealed</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Profunctor</span>&lt;<span style="color:#2b91af;">A</span>,&nbsp;<span style="color:#2b91af;">B</span>&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;Profunctor&lt;A1,&nbsp;B1&gt;&nbsp;<span style="color:#74531f;">DiMap</span>&lt;<span style="color:#2b91af;">A1</span>,&nbsp;<span style="color:#2b91af;">B1</span>&gt;(Func&lt;A1,&nbsp;A&gt;&nbsp;<span style="color:#1f377f;">contraSelector</span>,&nbsp;Func&lt;B,&nbsp;B1&gt;&nbsp;<span style="color:#1f377f;">coSelector</span>)
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;...</span></pre>
	</p>
	<p>
		Contrary to (covariant) functors, where C# will light up some extra compiler features if you name the mapping method <code>Select</code>, there's no extra language support for profunctors. Thus, you can call the method whatever you like, but here I've chosen the name <code>DiMap</code> just because that's what the <a href="https://www.haskell.org">Haskell</a> <a href="https://hackage.haskell.org/package/profunctors">Profunctors package</a> calls the corresponding function.
	</p>
	<p>
		Notice that in order to map the contravariant type argument <code>A</code> to <code>A1</code>, you must supply a selector that moves in the contrary direction: from <code>A1</code> to <code>A</code>. Mapping the covariant type argument <code>B</code> to <code>B1</code>, on the other hand, goes in the same direction: from <code>B</code> to <code>B1</code>.
	</p>
	<p>
		An example might look like this:
	</p>
	<p>
		<pre>Profunctor&lt;TimeSpan,&nbsp;<span style="color:blue;">double</span>&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;profunctor.DiMap&lt;<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>&gt;(TimeSpan.Parse,&nbsp;<span style="color:#1f377f;">d</span>&nbsp;=&gt;&nbsp;d&nbsp;%&nbsp;1&nbsp;==&nbsp;0);</pre>
	</p>
	<p>
		This example starts with a profunctor where the contravariant type is <code>TimeSpan</code> and the covariant type is <code>double</code>. Using <code>DiMap</code> you can map it to a <code>Profunctor&lt;string, bool&gt;</code>. In order to map the <code>profunctor</code> value's <code>TimeSpan</code> to the <code>projection</code> value's <code>string</code>, the method call supplies <code>TimeSpan.Parse</code>: a (partial) function that maps <code>string</code> to <code>TimeSpan</code>.
	</p>
	<p>
		The second argument maps the <code>profunctor</code> value's <code>double</code> to the <code>projection</code> value's <code>bool</code> by checking if <code>d</code> is an integer. The lambda expression <code><span style="color:#1f377f;">d</span>&nbsp;=&gt;&nbsp;d&nbsp;%&nbsp;1&nbsp;==&nbsp;0</code> implements a function from <code>double</code> to <code>bool</code>. That is, the profunctor <em>covaries</em> with that function.
	</p>
	<h3 id="3252cf7678234d0697ea0223b5659f5e">
		Covariant mapping <a href="#3252cf7678234d0697ea0223b5659f5e" title="permalink">#</a>
	</h3>
	<p>
		Given <code>DiMap</code> you can implement the standard <code>Select</code> method for functors.
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;Profunctor&lt;A,&nbsp;B1&gt;&nbsp;<span style="color:#74531f;">Select</span>&lt;<span style="color:#2b91af;">B1</span>&gt;(Func&lt;B,&nbsp;B1&gt;&nbsp;<span style="color:#1f377f;">selector</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;DiMap&lt;A,&nbsp;B1&gt;(<span style="color:#1f377f;">x</span>&nbsp;=&gt;&nbsp;x,&nbsp;selector);
}</pre>
	</p>
	<p>
		<a href="/2019/01/07/either-bifunctor">Equivalently to bifunctors</a>, when you have a function that maps both dimensions, you can map one dimension by using the identity function for the dimension you don't need to map. Here I've used the lambda expression <code>x =&gt; x</code> as the identity function.
	</p>
	<p>
		You can use this <code>Select</code> method with standard method-call syntax:
	</p>
	<p>
		<pre>Profunctor&lt;DateTime,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;DateTime,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=&nbsp;profunctor.Select(<span style="color:#1f377f;">s</span>&nbsp;=&gt;&nbsp;s.Length);</pre>
	</p>
	<p>
		or with query syntax:
	</p>
	<p>
		<pre>Profunctor&lt;DateTime,&nbsp;TimeSpan&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;DateTime,&nbsp;<span style="color:blue;">int</span>&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=&nbsp;<span style="color:blue;">from</span>&nbsp;ts&nbsp;<span style="color:blue;">in</span>&nbsp;profunctor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">select</span>&nbsp;ts.Minutes;</pre>
	</p>
	<p>
		All profunctors are also covariant functors.
	</p>
	<h3 id="171bd982cd5c48a69690ea10d9dbb7d4">
		Contravariant mapping <a href="#171bd982cd5c48a69690ea10d9dbb7d4" title="permalink">#</a>
	</h3>
	<p>
		Likewise, given <code>DiMap</code> you can implement a <code>ContraMap</code> method:
	</p>
	<p>
		<pre><span style="color:blue;">public</span>&nbsp;Profunctor&lt;A1,&nbsp;B&gt;&nbsp;<span style="color:#74531f;">ContraMap</span>&lt;<span style="color:#2b91af;">A1</span>&gt;(Func&lt;A1,&nbsp;A&gt;&nbsp;<span style="color:#1f377f;">selector</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#8f08c4;">return</span>&nbsp;DiMap&lt;A1,&nbsp;B&gt;(selector,&nbsp;<span style="color:#1f377f;">x</span>&nbsp;=&gt;&nbsp;x);
}</pre>
	</p>
	<p>
		Using <code>ContraMap</code> is only possible with normal method-call syntax, since C# has no special understanding of contravariant functors:
	</p>
	<p>
		<pre>Profunctor&lt;<span style="color:blue;">long</span>,&nbsp;DateTime&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;<span style="color:blue;">string</span>,&nbsp;DateTime&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=&nbsp;profunctor.ContraMap&lt;<span style="color:blue;">string</span>&gt;(<span style="color:blue;">long</span>.Parse);</pre>
	</p>
	<p>
		All profunctors are also contravariant functors.
	</p>
	<p>
		While you can implement <code>Select</code> and <code>ContraMap</code> from <code>DiMap</code>, it's also possible to go the other way. If you have <code>Select</code> and <code>ContraMap</code> you can implement <code>DiMap</code>.
	</p>
	<h3 id="db28768129484d5d8fcf6591f164c2ad">
		Laws <a href="#db28768129484d5d8fcf6591f164c2ad" title="permalink">#</a>
	</h3>
	<p>
		In the overall article series, I've focused on the laws that govern various universal abstractions. In this article, I'm going to treat this topic lightly, since it'd mostly be a reiteration of the laws that govern co- and contravariant functors.
	</p>
	<p>
		The only law I'll highlight is the profunctor identity law, which intuitively is a generalisation of the identity laws for co- and contravariant functors. If you map a profunctor in both dimensions, but use the identity function in both directions, nothing should change:
	</p>
	<p>
		<pre>Profunctor&lt;Guid,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;Guid,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=&nbsp;profunctor.DiMap((Guid&nbsp;<span style="color:#1f377f;">g</span>)&nbsp;=&gt;&nbsp;g,&nbsp;<span style="color:#1f377f;">s</span>&nbsp;=&gt;&nbsp;s);</pre>
	</p>
	<p>
		Here I've used two lambda expressions to implement the identity function. While they're two different lambda expressions, they both 'implement' the general identity function. If you aren't convinced, we can demonstrate the idea like this instead:
	</p>
	<p>
		<pre>T&nbsp;<span style="color:#74531f;">id</span>&lt;<span style="color:#2b91af;">T</span>&gt;(T&nbsp;<span style="color:#1f377f;">x</span>)&nbsp;=&gt;&nbsp;x;
Profunctor&lt;Guid,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;<span style="color:#1f377f;">profunctor</span>&nbsp;=&nbsp;CreateAProfunctor();
Profunctor&lt;Guid,&nbsp;<span style="color:blue;">string</span>&gt;&nbsp;<span style="color:#1f377f;">projection</span>&nbsp;=&nbsp;profunctor.DiMap&lt;Guid,&nbsp;<span style="color:blue;">string</span>&gt;(id,&nbsp;id);</pre>
	</p>
	<p>
		This alternative representation defines a <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/local-functions">local function</a> called <code>id</code>. Since it's generic, you can use it as both arguments to <code>DiMap</code>.
	</p>
	<p>
		The point of the identity law is that in both cases, <code>projection</code> should be equal to <code>profunctor</code>.
	</p>
	<h3 id="7b00d6198531450b86fa49d9f3133806">
		Usefulness <a href="#7b00d6198531450b86fa49d9f3133806" title="permalink">#</a>
	</h3>
	<p>
		Are profunctors useful in everyday programming? So far, I've found no particular use for them. This mirrors my experience with contravariant functors, which I also find little use for. Why should we care, then?
	</p>
	<p>
		It turns out that, while we rarely work explicitly with profunctors, they're everywhere. Normal functions are profunctors.
	</p>
	<ul>
		<li>Reader as a profunctor</li>
	</ul>
	<p>
		In addition to normal functions (which <a href="/2021/08/30/the-reader-functor">are both covariant</a> and <a href="/2021/10/04/reader-as-a-contravariant-functor">contravariant</a>) other profunctors exist. At the time that I'm writing this article, I've no particular plans to add articles about any other profunctors, but if I do, I'll add them to the above list. Examples include Kleisli arrows and profunctor optics.
	</p>
	<p>
		The reason I find it worthwhile to learn about profunctors is that this way of looking at well-behaved functions shines an interesting light on the fabric of computation, so to speak. In a future article, I'll expand on that topic.
	</p>
	<h3 id="da045552d1064ff88ac2eb7fb4ce18d7">
		Conclusion <a href="#da045552d1064ff88ac2eb7fb4ce18d7" title="permalink">#</a>
	</h3>
	<p>
		A <em>profunctor</em> is a functor that is covariant in one dimension and contravariant in another dimension. While various exotic examples exist, the only example that you'd tend to encounter in mainstream programming is the Reader profunctor, also known simply as <em>functions</em>.
	</p>
	<p>
		<strong>Next:</strong> Reader as a profunctor.
	</p>
</div>